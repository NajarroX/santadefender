<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EL SANTA DEFENDER</title>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: monospace;
            position: relative;
        }

        /* Estilo del Canvas Base (relaciÃ³n 800x600) */
        #gameCanvas {
            border: 4px solid #cc0000;
            background-color: #006600; 
            touch-action: none; 
            cursor: pointer; 
            /* Reglas Responsive */
            display: block;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
        }

        /* --- Control de Audio --- */
        #audioToggle {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #cc0000;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            display: none;
            pointer-events: auto;
        }

        /* --- Controles TÃ¡ctiles (Joystick) --- */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: none;
            pointer-events: auto;
        }

        .joystick-container {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            position: absolute;
            touch-action: none;
        }

        .action-button {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #cc0000;
            border: 5px solid #fff;
            color: #fff;
            font-size: 1.5em;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: auto;
            display: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <button id="audioToggle">ðŸ”Š</button>

    <div class="controls" id="mobileControls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
    </div>
    <div class="action-button" id="shootButton">FUEGO</div>

    <script>
        // --- 1. CONFIGURACIÃ“N INICIAL Y DETECCIÃ“N ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_W = 800;
        const BASE_H = 600;
        let W = BASE_W; 
        let H = BASE_H;
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Estados del Juego
        let gameState = 'TITLE';

        // Referencias a los controles y el nuevo botÃ³n de audio
        const controls = document.getElementById('mobileControls');
        const shootButton = document.getElementById('shootButton');
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const audioToggle = document.getElementById('audioToggle');

        // Constantes del juego
        const PLAYER_SPEED = 4;
        const BULLET_SPEED = 8;
        const JOYSTICK_RADIUS = 75; 
        const PHRASE_DURATION = 300; 
        const PHRASE_INTERVAL = 8000; 
        const HIT_DURATION = 10; // DuraciÃ³n de la animaciÃ³n de golpe de Santa
        const GLITCH_DURATION = 15; // DuraciÃ³n del efecto glitch en el Ã¡rbol
        
        // --- POWER-UP CONSTANTES ---
        const ENEMIES_FOR_POWERUP = 10;
        const POWERUP_DURATION = 300; 
        const INVINCIBILITY_PHRASE_DURATION = 90; 
        const INVINCIBILITY_PHRASE_CHANCE = 0.40; 
        
        // --- TIPOS DE ENEMIGOS (Velocidad Variable) ---
        const ENEMY_TYPES = [
            { speed: 1.5, color: '#666666', spawnWeight: 60 }, // Tacuche Gris
            { speed: 2.5, color: '#990000', spawnWeight: 30 }, // Tacuche Rojo
            { speed: 1.0, color: '#000066', spawnWeight: 10 } // Tacuche Azul
        ];
        let spawnRate = 0.02;

        // --- HITO DE PUNTUACIÃ“N Y CURACIÃ“N ---
        const HEAL_SCORE_HIT = 1000;
        let lastHealScore = 0;
        const GLOW_DURATION = 30; 

        // --- 2. OBJETOS DEL JUEGO Y ESTADO ---
        let santa = {
            x: BASE_W / 2,
            y: BASE_H / 2,
            size: 20, 
            color: 'red',
            health: 10,
            maxHealth: 10, 
            dirX: 0,
            dirY: 0,
            shooting: false,
            lastShotTime: 0,
            fireRate: 200,
            frame: 0,
            invincible: false, 
            invincibleTimer: 0,
            hitTimer: 0
        };

        const ENEMY_BASE_SIZE = 18; // TAMAÃ‘O INTERMEDIO PARA EL ENEMIGO

        let tree = {
            x: BASE_W / 2,
            y: BASE_H / 2,
            size: 40,
            color: '#00aa00', 
            health: 50,
            maxHealth: 50,
            healingGlowTimer: 0, 
            damageGlitchTimer: 0 
        };
        const treeHealthMax = tree.maxHealth;

        let bullets = [];
        let enemies = [];
        let explosions = []; 
        let floatingTexts = []; 
        let score = 0;
        let enemiesDefeatedSincePowerUp = 0; 
        let powerUpTimer = 0; 
        let gameFrame = 0; 
        
        let dialogue = {
            message: "Â¡Feliz Navidad! O como lo llama el 1%, 'Temporada de Consumo Forzado'.",
            duration: PHRASE_DURATION,
            powerUpMessage: null 
        };

        const invincibilityPhrases = [
            "Â¡Fuera de aquÃ­, parÃ¡sitos capitalistas!",
            "Â¡El capital no puede con la magia de un Santa sindicalizado!",
            "Â¡El Ãºnico regalo que darÃ© es esta paliza! Â¡Por un Polo Norte libre de explotaciÃ³n!"
        ];
        
        const sarcasticPhrases = [
            { min: 40, phrases: [
                "Â¡Luchando por el Ã¡rbol, el Ãºnico bien pÃºblico que queda en pie!", 
                "Â¡Mis elfos no tienen sindicato, son la verdadera tragedia aquÃ­, no estos demonios!", 
                "Â¡La avaricia ha creado monstruos... literalmente! Â¡Que ironÃ­a!", 
                "Â¡El precio de la hora extra es lo que realmente duele, no sus mordiscos!", 
                "Â¡Defender este Ã¡rbol es la nueva 'responsabilidad social corporativa'!"
            ] },
            { min: 25, phrases: [
                "Â¿En serio? Â¿Tantos enemigos y la riqueza sigue concentrada en los de arriba?", 
                "Â¡Esto es lo que pasa cuando privatizas el Polo Norte!", 
                "Â¡No hay suficientes incentivos fiscales para seguir con esta masacre!", 
                "Â¡Al menos estos monstruos trabajan, a diferencia de los parÃ¡sitos de la junta directiva!", 
                "Â¡Mi nÃ³mina estÃ¡ congelada, pero mi furia no!"
            ] },
            { min: 1, phrases: [
                "Â¡La recesiÃ³n de salud llegÃ³ antes de lo esperado! Â¡SÃ¡lvese quien pueda!", 
                "Â¡Parece que el mercado se estÃ¡ 'ajustando' a la baja, justo como mi moral!", 
                "Â¡Si perdemos, que el Ã¡rbol se declare en bancarrota para salvar mis activos!", 
                "Â¡La prÃ³xima Navidad, los juguetes serÃ¡n hechos por la IA... y serÃ¡n aÃºn mÃ¡s caros!", 
                "Â¡El verdadero regalo es un sistema que funcione, no mÃ¡s juguetes!"
            ] }
        ];

        let timeSinceLastPhrase = 0;

        // --- WEB AUDIO API (Control y GeneraciÃ³n de Sonido) ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        let isMuted = false;
        let backgroundMusicSource = null; 

        const C4 = 261.63, D4 = 293.66, E4 = 329.63, F4 = 349.23, G4 = 392.00, A4 = 440.00; 
        const tempo = 0.25; 

        const melody = [
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 }, 
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: C4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: E4, duration: 2.0 }, 
            { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 },
            { freq: F4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.25 }, { freq: D4, duration: 0.25 },
            { freq: D4, duration: 0.5 }, { freq: D4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: G4, duration: 2.0 }, 
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: C4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: E4, duration: 2.0 }, 
            { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 },
            { freq: F4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.25 }, { freq: D4, duration: 0.25 },
            { freq: G4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: C4, duration: 2.0 } 
        ];


        function startBackgroundMusic() {
            if (backgroundMusicSource) {
                if (backgroundMusicSource.playbackState === backgroundMusicSource.PLAYING_STATE) {
                    try { backgroundMusicSource.stop(audioContext.currentTime); } catch (e) {}
                }
                backgroundMusicSource = null;
            }

            const playSequence = (time) => {
                if (gameState !== 'PLAYING' || isMuted) {
                    backgroundMusicSource = null;
                    return;
                }
                
                let currentTime = time;
                
                backgroundMusicSource = audioContext.createOscillator();
                backgroundMusicSource.type = 'square'; 

                const musicGain = audioContext.createGain();
                musicGain.gain.setValueAtTime(0.4, audioContext.currentTime); 
                
                backgroundMusicSource.connect(musicGain);
                musicGain.connect(masterGain); 

                melody.forEach(note => {
                    const duration = note.duration * tempo; 
                    
                    if (note.freq > 0) {
                         backgroundMusicSource.frequency.setValueAtTime(note.freq, currentTime);
                         musicGain.gain.setValueAtTime(0.4, currentTime);
                         musicGain.gain.exponentialRampToValueAtTime(0.0001, currentTime + duration * 0.95);
                    } else {
                         musicGain.gain.setValueAtTime(0.0001, currentTime);
                    }
                    
                    currentTime += duration;
                });
                
                backgroundMusicSource.start(time);
                backgroundMusicSource.stop(currentTime); 
                
                backgroundMusicSource.onended = () => {
                    if (gameState === 'PLAYING' && !isMuted) {
                        playSequence(audioContext.currentTime);
                    } else {
                         backgroundMusicSource = null; 
                    }
                };
            };
            
            playSequence(audioContext.currentTime);
        }

        function playSound(frequency, duration, type, endFrequency = frequency, volume = 0.5) {
            if (isMuted) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            if (endFrequency !== frequency) {
                oscillator.frequency.linearRampToValueAtTime(endFrequency, audioContext.currentTime + duration);
            }

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(masterGain);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playExplosion(pitch) {
            playSound(pitch, 0.1, 'triangle', pitch * 0.5, 0.6);
        }

        function playHealSound() {
            playSound(400, 0.15, 'sine', 800, 0.8); 
        }

        function toggleAudio() {
            isMuted = !isMuted;
            if (isMuted) {
                masterGain.gain.setValueAtTime(0, audioContext.currentTime);
                audioToggle.textContent = 'ðŸ”‡';
                
                if (backgroundMusicSource) {
                     try { backgroundMusicSource.stop(audioContext.currentTime); } catch (e) {}
                     backgroundMusicSource = null;
                }
                
            } else {
                masterGain.gain.setValueAtTime(1, audioContext.currentTime);
                audioToggle.textContent = 'ðŸ”Š';
                
                if (gameState === 'PLAYING' && !backgroundMusicSource) {
                     startBackgroundMusic();
                }
            }
        }
        
        audioToggle.addEventListener('click', toggleAudio);
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Tab' && gameState === 'PLAYING') {
                e.preventDefault();
                toggleAudio();
            }
        });
        
        // --- CLASE EXPLOSIÃ“N ---
        class Explosion {
            constructor(x, y, color) {
                this.particles = [];
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        size: Math.random() * 4 + 2, 
                        color: color,
                        vx: Math.random() * 6 - 3, 
                        vy: Math.random() * 6 - 3, 
                        life: 30 
                    });
                }
            }
            update() {
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                });
                this.particles = this.particles.filter(p => p.life > 0);
                return this.particles.length > 0;
            }
            draw() {
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                });
            }
        }

        // --- CLASE PARA TEXTOS FLOTANTES ---
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.vy = -1.5; // Velocidad vertical (sube)
                this.life = 60; // DuraciÃ³n en frames (aprox 1 segundo)
                this.maxLife = 60;
            }
            update() {
                this.y += this.vy;
                this.life--;
                return this.life > 0; // Retorna true si sigue vivo
            }
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                
                ctx.fillStyle = this.color;
                ctx.font = '24px monospace';
                ctx.textAlign = 'center';
                
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 3;
                
                ctx.fillText(this.text, this.x, this.y);
                
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }
        
        // --- 3. RESPONSIVE DESIGN Y MANEJO DE VENTANA ---

        function resizeGame() {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const aspectR = BASE_W / BASE_H;
            
            let newW, newH;

            if (viewportW / viewportH > aspectR) {
                newH = viewportH;
                newW = viewportH * aspectR;
            } else {
                newW = viewportW;
                newH = viewportW / aspectR;
            }
            
            canvas.style.width = newW + 'px';
            canvas.style.height = newH + 'px';

            W = BASE_W;
            H = BASE_H;
            canvas.width = W;
            canvas.height = H;
        }

        window.addEventListener('resize', resizeGame);
        resizeGame();


        // --- 4. MANEJO DE EVENTOS (TÃ­tulo y Controles) ---
        
        function handleStartGame() {
            if (gameState === 'TITLE') {
                audioContext.resume();
                
                playSound(440, 0.01, 'sine', 440, 0); 
                
                gameState = 'PLAYING';
                resetGame();
                
                startBackgroundMusic(); 

                if (isMobile) {
                    controls.style.display = 'block';
                    shootButton.style.display = 'flex';
                }
                audioToggle.style.display = 'block';
            }
        }

        canvas.addEventListener('mousedown', handleStartGame);
        canvas.addEventListener('touchstart', (e) => {
            if (gameState === 'TITLE') {
                e.preventDefault();
                handleStartGame();
            }
        });
        
        // --- Controles de juego (Joystick y Teclado) ---
        let keys = {};
        if (!isMobile) {
            window.addEventListener('keydown', (e) => {
                if (gameState === 'PLAYING') {
                    keys[e.code] = true;
                }
            });
            window.addEventListener('keyup', (e) => {
                if (gameState === 'PLAYING') {
                    keys[e.code] = false;
                    if (e.code === 'Space') santa.shooting = false; 
                }
            });
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = true;
            });
            window.addEventListener('mouseup', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = false;
            });
        }
        
        let joystickActive = false;
        let startX, startY;

        if (isMobile) {
            joystickContainer.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            });
            joystickContainer.addEventListener('touchmove', (e) => {
                if (!joystickActive || gameState !== 'PLAYING') return;
                const touch = e.touches[0];
                let deltaX = touch.clientX - startX;
                let deltaY = touch.clientY - startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > JOYSTICK_RADIUS) {
                    deltaX = (deltaX / distance) * JOYSTICK_RADIUS;
                    deltaY = (deltaY / distance) * JOYSTICK_RADIUS;
                }
                joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                santa.dirX = deltaX / JOYSTICK_RADIUS;
                santa.dirY = deltaY / JOYSTICK_RADIUS;
            });
            const resetJoystick = () => {
                joystickActive = false;
                santa.dirX = 0;
                santa.dirY = 0;
                joystickHandle.style.transform = `translate(0px, 0px)`;
            };
            joystickContainer.addEventListener('touchend', resetJoystick);
            joystickContainer.addEventListener('touchcancel', resetJoystick);

            shootButton.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = true;
            });
            shootButton.addEventListener('touchend', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = false;
            });
        }


        // --- 5. LÃ“GICA DEL JUEGO (UPDATE) ---

        function handleShooting(deltaTime) {
            const currentFireRate = (santa.invincibleTimer > 0) ? 50 : santa.fireRate;
            
            if ((!isMobile && (keys['Space'] || santa.shooting)) || (isMobile && santa.shooting) || (santa.invincibleTimer > 0)) {
                const currentTime = Date.now();
                if (currentTime - santa.lastShotTime > currentFireRate) {
                    const dx = tree.x - santa.x;
                    const dy = tree.y - santa.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const nx = dx / dist;
                    const ny = dy / dist;

                    bullets.push({
                        x: santa.x,
                        y: santa.y,
                        size: (santa.invincibleTimer > 0) ? 12 : 8,
                        color: (santa.invincibleTimer > 0) ? '#00FFFF' : 'yellow',
                        dirX: nx,
                        dirY: ny
                    });
                    santa.lastShotTime = currentTime;
                    playSound(700, 0.05, 'square');
                }
            }
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.dirX * BULLET_SPEED;
                bullet.y += bullet.dirY * BULLET_SPEED;

                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        explosions.push(new Explosion(enemy.x, enemy.y, enemy.color)); 
                        
                        // AÃ±adir texto de puntuaciÃ³n
                        floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+10', '#00FFFF'));

                        enemies.splice(j, 1); 
                        bullets.splice(i, 1); 
                        score += 10;
                        enemiesDefeatedSincePowerUp++; // CONTEO DE POWERUP
                        playExplosion(300);
                        
                        hit = true;
                        break;
                    }
                }

                if (!hit && (bullet.x < 0 || bullet.x > W || bullet.y < 0 || bullet.y > H)) {
                    bullets.splice(i, 1);
                }
            }
        }
        
        function updatePowerUp(deltaTime) {
            if (santa.invincibleTimer > 0) {
                santa.invincibleTimer -= (deltaTime / (1000 / 60)); 
                if (santa.invincibleTimer <= 0) {
                    santa.invincible = false;
                    santa.invincibleTimer = 0;
                    dialogue.message = "Â¡Se agotÃ³ la invencibilidad!";
                    dialogue.duration = PHRASE_DURATION;
                    dialogue.powerUpMessage = null; 
                }
            }
            
            if (enemiesDefeatedSincePowerUp >= ENEMIES_FOR_POWERUP) {
                santa.health = santa.maxHealth; 
                santa.invincible = true;
                santa.invincibleTimer = POWERUP_DURATION; 
                enemiesDefeatedSincePowerUp = 0; // RESET DE CONTEO
                dialogue.powerUpMessage = invincibilityPhrases[Math.floor(Math.random() * invincibilityPhrases.length)]; 
                dialogue.message = dialogue.powerUpMessage;
                dialogue.duration = INVINCIBILITY_PHRASE_DURATION;
                playSound(300, 0.2, 'sawtooth', 700);
            }
        }

        function checkHealHit() {
            if (score >= lastHealScore + HEAL_SCORE_HIT) {
                lastHealScore += HEAL_SCORE_HIT;

                const healAmount = tree.maxHealth * 0.5;
                const oldHealth = tree.health;
                const newHealth = Math.min(tree.maxHealth, tree.health + healAmount);
                
                if (newHealth > oldHealth) {
                    tree.health = newHealth;
                    dialogue.message = `Â¡HITO! El Ã¡rbol se ha regenerado un 50%. HP: ${tree.health}`;
                    dialogue.duration = PHRASE_DURATION;
                    tree.healingGlowTimer = GLOW_DURATION; 
                    playHealSound();
                }
            }
        }

        function updatePlayerMovement() {
            const originalY = BASE_H / 2 + santa.y - (BASE_H / 2);

            if (!isMobile) {
                santa.dirX = 0;
                santa.dirY = 0;
                if (keys['KeyA'] || keys['ArrowLeft']) santa.dirX = -1;
                if (keys['KeyD'] || keys['ArrowRight']) santa.dirX = 1;
                if (keys['KeyW'] || keys['ArrowUp']) santa.dirY = -1;
                if (keys['KeyS'] || keys['ArrowDown']) santa.dirY = 1;
            }
            
            const magnitude = Math.sqrt(santa.dirX * santa.dirX + santa.dirY * santa.dirY);

            // ANIMACIÃ“N DE GOLPE (Salto)
            if (santa.hitTimer > 0) {
                // PequeÃ±o retroceso en Y para simular el golpe
                santa.y -= 3 * (santa.hitTimer / HIT_DURATION);
                santa.hitTimer--;
            }
            
            // Movimiento de IDLE (RespiraciÃ³n)
            if (magnitude === 0 && santa.hitTimer === 0) {
                // Desplazamiento vertical en IDLE (ciclo sinusoidal)
                santa.y += Math.sin(gameFrame * 0.05) * 0.2; 
                santa.frame = 0;
            } else if (santa.hitTimer === 0) {
                // Movimiento normal
                const nx = santa.dirX / magnitude;
                const ny = santa.dirY / magnitude;
                santa.x += nx * PLAYER_SPEED;
                santa.y += ny * PLAYER_SPEED;
                santa.frame = (santa.frame + 0.1) % 2; 
            }

            // RestricciÃ³n de lÃ­mites de pantalla
            santa.x = Math.max(santa.size / 2, Math.min(W - santa.size / 2, santa.x));
            santa.y = Math.max(santa.size / 2, Math.min(H - santa.size / 2, santa.y));
        }
        function updateExplosions() {
             for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                if (!floatingTexts[i].update()) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function spawnEnemies() {
            if (Math.random() < spawnRate) { 
                
                let totalWeight = ENEMY_TYPES.reduce((sum, type) => sum + type.spawnWeight, 0);
                let randomValue = Math.random() * totalWeight;
                let selectedType = ENEMY_TYPES[0];

                for (const type of ENEMY_TYPES) {
                    randomValue -= type.spawnWeight;
                    if (randomValue <= 0) {
                        selectedType = type;
                        break;
                    }
                }

                const size = ENEMY_BASE_SIZE; // Usar la nueva constante
                const edge = Math.floor(Math.random() * 4); 
                let x, y;
                switch (edge) {
                    case 0: x = Math.random() * W; y = -size; break;
                    case 1: x = W + size; y = Math.random() * H; break;
                    case 2: x = Math.random() * W; y = H + size; break;
                    case 3: x = -size; y = Math.random() * H; break;
                }
                
                enemies.push({ 
                    x: x, 
                    y: y, 
                    size: size, 
                    color: selectedType.color,
                    speed: selectedType.speed
                });
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = tree.x - enemy.x;
                const dy = tree.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / dist;
                const ny = dy / dist;
                
                enemy.x += nx * enemy.speed; 
                enemy.y += ny * enemy.speed;
                
                let destroyed = false;

                // LÃ“GICA DE DAÃ‘O A SANTA CON INVENCIBILIDAD
                if (checkCollision(enemy, santa)) {
                    if (!santa.invincible) {
                        santa.health -= 1;
                        santa.hitTimer = HIT_DURATION; // ACTIVA ANIMACIÃ“N DE GOLPE
                        explosions.push(new Explosion(enemy.x, enemy.y, 'white'));
                        playSound(150, 0.1, 'square', 100);
                        
                        if (santa.health <= 0) {
                            alert('GAME OVER! Santa ha sido sobrepasado. PuntuaciÃ³n: ' + score);
                            playSound(200, 1.0, 'sine', 50);
                            gameState = 'TITLE';
                            resetGame();
                            if (isMobile) {
                                controls.style.display = 'none';
                                shootButton.style.display = 'none';
                            }
                            audioToggle.style.display = 'none';
                            return; 
                        }
                    } else {
                        explosions.push(new Explosion(enemy.x, enemy.y, '#FF00FF'));
                    }

                    enemies.splice(i, 1);
                    destroyed = true;
                }
                
                // LÃ³gica de daÃ±o al Ãrbol (Solo si no ha sido destruido al daÃ±ar a Santa)
                if (!destroyed && checkCollision(enemy, tree)) {
                    tree.health -= 1;
                    
                    // ðŸ”¥ ACTIVACIÃ“N DEL GLITCH DE DAÃ‘O
                    tree.damageGlitchTimer = GLITCH_DURATION; 
                    
                    enemies.splice(i, 1);
                    
                    // AÃ±adir texto de daÃ±o al Ã¡rbol
                    floatingTexts.push(new FloatingText(tree.x, tree.y - tree.size * 0.8, '-1', '#FF0000'));
                    
                    // ANIMACIÃ“N de CHOQUE con el ÃRBOL (ExplosiÃ³n roja/oscura que simula el aplastamiento)
                    explosions.push(new Explosion(enemy.x, enemy.y, '#990000')); 
                    
                    if (tree.health <= 0) {
                        alert('GAME OVER! El Ã¡rbol ha sido talado. PuntuaciÃ³n: ' + score);
                        playSound(200, 1.0, 'sine', 50);
                        gameState = 'TITLE'; 
                        resetGame(); 
                        if (isMobile) {
                            controls.style.display = 'none';
                            shootButton.style.display = 'none';
                        }
                        audioToggle.style.display = 'none';
                        return;
                    }
                }
            }
        }
        
        function updateDialogue(deltaTime) {
            if (dialogue.duration > 0) {
                dialogue.duration -= (deltaTime / (1000 / 60)); 
            }

            if (santa.invincibleTimer > 0 && dialogue.powerUpMessage && dialogue.duration <= 0) {
                if (Math.random() < INVINCIBILITY_PHRASE_CHANCE) {
                    dialogue.message = dialogue.powerUpMessage;
                    dialogue.duration = INVINCIBILITY_PHRASE_DURATION; 
                }
                return;
            }

            timeSinceLastPhrase += deltaTime;
            if (timeSinceLastPhrase > PHRASE_INTERVAL && dialogue.duration <= 0 && santa.invincibleTimer <= 0) {
                let eligiblePhrases = [];
                for(const group of sarcasticPhrases) {
                    if (tree.health >= group.min) {
                        eligiblePhrases = group.phrases;
                        break;
                    }
                }
                if (eligiblePhrases.length > 0) {
                    const newPhrase = eligiblePhrases[Math.floor(Math.random() * eligiblePhrases.length)];
                    dialogue.message = newPhrase;
                    dialogue.duration = PHRASE_DURATION; 
                    timeSinceLastPhrase = 0;
                }
            }
        }
        function checkCollision(objA, objB) {
             const sizeA = objA.size || 0; 
             const sizeB = objB.size || 0;

             // Ajustar ligeramente la zona de colisiÃ³n para que sea menos sensible.
             const overlap = 0.8; 
             
             return objA.x < objB.x + sizeB * overlap && 
                    objA.x + sizeA * overlap > objB.x &&
                    objA.y < objB.y + sizeB * overlap && 
                    objA.y + sizeA * overlap > objB.y;
        }


        function updateGame(deltaTime) {
            updatePlayerMovement();
            updatePowerUp(deltaTime); 
            handleShooting(deltaTime);
            updateBullets();
            updateExplosions(); 
            updateFloatingTexts();
            spawnEnemies();
            updateEnemies();
            updateDialogue(deltaTime); 
            checkHealHit();
            
            gameFrame++; 
            if (tree.healingGlowTimer > 0) {
                tree.healingGlowTimer--;
            }
        }

        // --- 6. RENDERIZADO (DRAW) ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x - w / 2, y - h / 2, w, h);
        }
        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function hueToRgb(p) {
            const h = p % 360;
            const chroma = 255; 
            const x = chroma * (1 - Math.abs((h / 60) % 2 - 1));
            
            let r = 0, g = 0, b = 0;

            if (h >= 0 && h < 60) {
                [r, g, b] = [chroma, x, 0];
            } else if (h >= 60 && h < 120) {
                [r, g, b] = [x, chroma, 0];
            } else if (h >= 120 && h < 180) {
                [r, g, b] = [0, chroma, x];
            } else if (h >= 180 && h < 240) {
                [r, g, b] = [0, x, chroma];
            } else if (h >= 240 && h < 300) {
                [r, g, b] = [x, 0, chroma];
            } else if (h >= 300 && h < 360) {
                [r, g, b] = [chroma, 0, x];
            }
            
            const toHex = (c) => Math.round(c).toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }


        function drawSanta(x, y, size, frame) {
            // La invisibilidad es un parpadeo, no necesitamos dibujarlo si estÃ¡ parpadeando
            if (santa.invincible && Math.floor(santa.invincibleTimer / 5) % 2 === 0) {
                return;
            }

            const s = size; 
            const halfS = s / 2; 
            const p = s / 20; // 1 pixel de referencia si size es 20
            
            // AnimaciÃ³n de Caminar (piernas alternando)
            let legOffset = 0;
            if (santa.dirX !== 0 || santa.dirY !== 0) { 
                legOffset = (Math.floor(frame) === 0) ? s * 0.15 : -s * 0.15;
            }

            // AnimaciÃ³n de Golpeado (retroceso de torso)
            let bodyOffset = 0;
            if (santa.hitTimer > 0) {
                bodyOffset = -s * 0.1; 
            }
            
            // Factor de desplazamiento general para centrar el diseÃ±o mÃ¡s grande/cabeza
            const headYOffset = -s * 0.2; 
            const bodyYOffset = -s * 0.1; 

            // --- 1. GORRO Y POMPÃ“N (Grande) ---
            // Base del gorro (rojo)
            drawRect(x, y - halfS + p * 2 + headYOffset, s * 0.9, s * 0.4, 'red'); 
            // PompÃ³n (blanco)
            drawCircle(x + s * 0.35, y - halfS + p + headYOffset, s * 0.15, 'white'); 
            // Borde blanco
            drawRect(x, y - halfS + p * 5 + headYOffset, s, p * 2, 'white'); 
            
            // -- 2. CARA Y BARBA (Grande y redonda) --
            // Cara (piel)
            drawRect(x, y - s * 0.1 + headYOffset, s * 0.4, s * 0.2, '#FFDBAC'); 
            // Ojos (Negros)
            drawRect(x - s * 0.1, y - s * 0.2 + headYOffset, p, p, 'black');
            drawRect(x + s * 0.1, y - s * 0.2 + headYOffset, p, p, 'black');
            
            // Barba (Blanca, cubre gran parte del torso superior)
            drawRect(x, y + s * 0.2 + headYOffset, s * 1.2, s * 0.4, 'white'); 
            
            // -- 3. CUERPO (PequeÃ±o y Compacto) --
            // Traje Rojo
            drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.8, s * 0.35, 'red');
            // CinturÃ³n Negro
            drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.8, s * 0.1, 'black');
            // Hebilla Dorada
            drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.2, s * 0.15, '#FFD700'); 

            // -- 4. PIERNAS Y BOTAS (Muy PequeÃ±as) --
            // Piernas (Negras)
            drawRect(x - s * 0.2 + legOffset, y + s * 0.85 + bodyYOffset, s * 0.15, s * 0.2, 'black'); 
            drawRect(x + s * 0.2 + legOffset, y + s * 0.85 + bodyYOffset, s * 0.15, s * 0.2, 'black'); 
        }

        function drawTitleText(x, y, message, fontSize, color, align = 'center') {
            ctx.fillStyle = color;
            ctx.font = `${fontSize}px monospace`;
            ctx.textAlign = align;
            ctx.fillText(message, x, y);
        }

        function drawTitleScreen() {
            ctx.fillStyle = '#003300';
            ctx.fillRect(0, 0, W, H);

            drawTitleText(W / 2, H / 2 - 150, "EL SANTA DEFENDER", 60, '#cc0000');
            drawTitleText(W / 2, H / 2 - 80, "La Lucha Contra la Codicia", 24, 'white');
            drawSanta(W / 4, H / 2 + 50, 40, 0); 
            drawTitleText(W / 4, H / 2 + 100, "Santa", 20, 'white');
            
            const instructions = isMobile ? 
                ["**MOVIL**:", "Joystick Izq: Mover", "BotÃ³n FUEGO: Disparar", "Toca la pantalla para JUGAR"] :
                ["**PC**:", "WASD / Flechas: Mover", "Espacio / Click: Disparar", "TAB: Silenciar Audio", "Click en la pantalla para JUGAR"];
            
            let lineY = H / 2 - 50;
            const lineX = W * 0.6;

            instructions.forEach(line => {
                const color = line.startsWith('**') ? '#ffcc00' : 'white';
                const text = line.replace(/\*\*/g, '');
                drawTitleText(lineX, lineY, text, 20, color, 'left'); 
                lineY += 30;
            });

            drawTitleText(W / 2, H - 50, "Â¡La Navidad depende de ti!", 24, '#00aa00');
        }

        function applyPsychedelicGlitch() {
            ctx.translate(Math.random() * 4 - 2, Math.random() * 4 - 2); 
            if (Math.random() < 0.5) {
                ctx.globalAlpha = 0.8;
                ctx.filter = `hue-rotate(${Math.random() * 360}deg) saturate(200%)`;
            } else {
                 ctx.filter = 'none';
                 ctx.globalAlpha = 1;
            }
        }
        
        function drawGameObjects() {
            // Aplicar Glitch de Invencibilidad a todo el fondo
            if (santa.invincibleTimer > 0) {
                applyPsychedelicGlitch();
            } else {
                ctx.filter = 'none';
                ctx.globalAlpha = 1;
            }
            
            // Texto de fondo
            const titleText = "EL SANTA DEFENDER";
            const fontSize = 48; 
            const titleColor = '#004d00'; 
            ctx.fillStyle = titleColor;
            ctx.font = `${fontSize}px monospace`;
            ctx.textAlign = 'center';
            const titleY = H / 2 + fontSize * 1.5;
            ctx.fillText(titleText, W / 2 + 2, titleY + 2);
            ctx.fillText(titleText, W / 2 - 2, titleY - 2);
            ctx.fillText(titleText, W / 2, titleY);

            drawTree();
            
            // Reestablecer el contexto despuÃ©s del Ã¡rbol (que tiene un reset interno)
            if (santa.invincibleTimer > 0) {
                 ctx.filter = 'none';
                 ctx.globalAlpha = 1;
                 ctx.setTransform(1, 0, 0, 1, 0, 0); 
                 applyPsychedelicGlitch(); // Reaplicar glitch para enemigos y balas
            }

            drawEnemies();
            drawBullets();
            drawSanta(santa.x, santa.y, santa.size, santa.frame); 
            explosions.forEach(exp => exp.draw());
            
            // DIBUJA LOS TEXTOS FLOTANTES
            floatingTexts.forEach(t => t.draw());

            // Restablecer el contexto para evitar que el HUD se vea afectado por el glitch
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.filter = 'none';
            ctx.globalAlpha = 1;
            
            drawHUD();
        }
        
        function drawTree() {
            const healthRatio = tree.health / tree.maxHealth;
            const treeTop = tree.y - tree.size;
            const treeBaseY = tree.y + tree.size / 2;
            const treeW = tree.size;
            
            // --- APLICAR EFECTO GLITCH DE DAÃ‘O ---
            if (tree.damageGlitchTimer > 0) {
                // Reducir el timer
                tree.damageGlitchTimer--;
                
                // 1. Desplazamiento de pantalla (vibraciÃ³n)
                const intensity = tree.damageGlitchTimer / GLITCH_DURATION;
                const offsetX = Math.random() * 8 * intensity - 4 * intensity; // -4 a 4
                const offsetY = Math.random() * 8 * intensity - 4 * intensity; 
                
                ctx.translate(offsetX, offsetY); 
                
                // 2. Filtro de color (rojo/glitch)
                ctx.filter = `hue-rotate(${Math.random() * 30}deg) saturate(300%) contrast(150%)`;
            }
            // ---------------------------------------------
            
            // --- 1. Aura Iridiscente Pulsante (Basado en el HP) ---
            const hue = (gameFrame * 2) % 360; 
            const auraColor = hueToRgb(hue);
            
            const baseGlow = 10;
            const glowPulse = Math.sin(gameFrame * 0.1) * 3; 
            const glowSize = Math.max(0, baseGlow * healthRatio + glowPulse);
            
            if (healthRatio < 0.2) {
                ctx.shadowColor = `rgba(255, 0, 0, 1)`;
                ctx.shadowBlur = baseGlow * 1.2;
            } else {
                ctx.shadowColor = auraColor;
                ctx.shadowBlur = Math.max(5, glowSize);
            }
            
            const auraOffset = Math.max(5, baseGlow * healthRatio * 0.5); 

            // --- 2. Dibujar la Forma del Aura ---
            ctx.fillStyle = `rgba(255, 255, 255, ${healthRatio * 0.2 + 0.1})`; 
            ctx.beginPath();
            ctx.moveTo(tree.x, treeTop - auraOffset); 
            ctx.lineTo(tree.x - treeW - auraOffset, treeBaseY + auraOffset);
            ctx.lineTo(tree.x + treeW + auraOffset, treeBaseY + auraOffset);
            ctx.closePath();
            ctx.fill();

            // --- 3. Glow de CuraciÃ³n (Se superpone al iridiscente) ---
            if (tree.healingGlowTimer > 0) {
                const glowRatio = tree.healingGlowTimer / GLOW_DURATION;
                const glowAlpha = Math.sin(Math.PI * (1 - glowRatio)); 
                
                ctx.shadowColor = `rgba(0, 255, 0, 1)`; 
                ctx.shadowBlur = 25 * glowAlpha; 
                
                ctx.fillStyle = `rgba(0, 255, 0, ${glowAlpha * 0.5})`; 
                ctx.beginPath();
                ctx.moveTo(tree.x, treeTop - auraOffset); 
                ctx.lineTo(tree.x - treeW - auraOffset, treeBaseY + auraOffset);
                ctx.lineTo(tree.x + treeW + auraOffset, treeBaseY + auraOffset);
                ctx.closePath();
                ctx.fill();
            }

            // --- 4. Reiniciar el contexto (Sombra/Filtro) ---
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            
            // --- 5. Tronco ---
            drawRect(tree.x, tree.y + tree.size / 2 - 5, 10, 10, '#8B4513');
            
            // --- 6. Cuerpo del Ãrbol ---
            ctx.fillStyle = tree.color;
            ctx.beginPath();
            ctx.moveTo(tree.x, treeTop); 
            ctx.lineTo(tree.x - treeW, treeBaseY);
            ctx.lineTo(tree.x + treeW, treeBaseY);
            ctx.closePath();
            ctx.fill();
            
            // --- 7. Luces Animadas ---
            const pulse = Math.floor(gameFrame / 10) % 3; 
            const colors = ['yellow', 'red', 'blue'];
            
            drawCircle(tree.x - 10, tree.y - 15, 3, colors[(pulse + 0) % 3]);
            drawCircle(tree.x + 15, tree.y, 3, colors[(pulse + 1) % 3]);
            drawCircle(tree.x - 5, tree.y + 10, 3, colors[(pulse + 2) % 3]);
            
            // --- 8. Reiniciar la transformaciÃ³n ---
            // Esto es CRÃTICO para que solo el Ã¡rbol se vea afectado.
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.filter = 'none';
        }

        function drawEnemies() {
            enemies.forEach(e => {
                const x = e.x;
                const y = e.y;
                
                // AnimaciÃ³n de Movimiento/PulsaciÃ³n (tamaÃ±o variable)
                const pulse = 1 + Math.sin(gameFrame * 0.1 * e.speed) * 0.05; 
                const s = ENEMY_BASE_SIZE * pulse; 
                const color = e.color; 
                const halfS = s / 2;
                
                // Color del traje (mÃ¡s oscuro que el color base del enemigo)
                let suitColor = color;
                if (color === '#666666') suitColor = '#444444'; 
                else if (color === '#990000') suitColor = '#660000'; 
                else if (color === '#000066') suitColor = '#000044'; 

                // --- 1. CABEZA (Calva y pÃ¡lida/demonÃ­aca) ---
                drawRect(x, y - halfS + s * 0.1, s * 0.6, s * 0.4, '#C0C0C0'); 

                // --- 2. DETALLES FACIALES (Gafas y Bigote) ---
                // Gafas Oscuras (RectÃ¡ngulo negro que cubre los ojos)
                drawRect(x, y - s * 0.1, s * 0.5, s * 0.15, 'black'); 
                
                // Bigote (PequeÃ±o trazo oscuro debajo de las gafas)
                drawRect(x, y + s * 0.05, s * 0.3, s * 0.05, '#333333'); 

                // --- 3. CUERPO / TACUCHE ---
                // Traje principal
                drawRect(x, y + s * 0.2, s * 0.8, s * 0.6, suitColor);

                // Cuello de la camisa (Blanco)
                drawRect(x, y - s * 0.05, s * 0.2, s * 0.1, 'white');

                // Corbata (Color base del enemigo, para identificar tipo)
                drawRect(x, y + s * 0.15, s * 0.1, s * 0.3, color); 
                
                // --- 4. PIERNAS Y ZAPATOS ---
                // SimulaciÃ³n de dos piernas (mÃ¡s oscuras)
                drawRect(x - s * 0.15, y + s * 0.6, s * 0.2, s * 0.3, '#333333'); 
                drawRect(x + s * 0.15, y + s * 0.6, s * 0.2, s * 0.3, '#333333'); 
            });
        }

        function drawBullets() {
            bullets.forEach(b => {
                drawRect(b.x, b.y, b.size, b.size, b.color);
            });
        }
        
        function drawDialogueBubble(x, y, message) {
            const FONT_SIZE = 16;
            const MAX_WIDTH_CHARS = 25; 
            const PADDING = 8;
            const LINE_HEIGHT = FONT_SIZE + 4;
            
            ctx.font = `${FONT_SIZE}px monospace`;
            ctx.textAlign = 'center';

            let lines = [message];
            let maxLineW = 0;
            
            if (message.length > MAX_WIDTH_CHARS) {
                const words = message.split(' ');
                lines = [''];
                let currentLine = 0;
                
                for (const word of words) {
                    if (lines[currentLine].length + word.length + 1 > MAX_WIDTH_CHARS && currentLine < 1) {
                        currentLine++;
                        lines.push(word + ' ');
                    } else {
                        lines[currentLine] += word + ' ';
                    }
                }
            }

            for (const line of lines) {
                maxLineW = Math.max(maxLineW, ctx.measureText(line.trim()).width);
            }

            const textWidth = maxLineW;
            const numLines = lines.length;
            const bubbleW = textWidth + PADDING * 2;
            const bubbleH = (numLines * LINE_HEIGHT) + PADDING * 1.5;
            
            const bubbleX = x - bubbleW / 2;
            const bubbleY = y - santa.size - bubbleH - 10; 

            ctx.fillStyle = 'white';
            ctx.fillRect(bubbleX, bubbleY, bubbleW, bubbleH);
            
            ctx.beginPath();
            ctx.moveTo(x - 5, bubbleY + bubbleH);
            ctx.lineTo(x + 5, bubbleY + bubbleH);
            ctx.lineTo(x, bubbleY + bubbleH + 6); 
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'black';
            let currentTextY = bubbleY + PADDING + LINE_HEIGHT * 0.75;
            
            lines.forEach((line, index) => {
                ctx.fillText(line.trim(), x, currentTextY + index * LINE_HEIGHT);
            });
        }


        function drawHUD() {
            ctx.fillStyle = 'white';
            ctx.font = '20px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText(`PuntuaciÃ³n: ${score}`, 10, 30);
            
            // --- BARRA DE SALUD DEL ÃRBOL ---
            const treeHealthRatio = tree.health / tree.maxHealth;
            const barWidth = 300;
            const barHeight = 15;
            const barX = W / 2 - barWidth / 2;
            const barY = 15;
            
            if (tree.healingGlowTimer > 0) {
                const glowAlpha = tree.healingGlowTimer / GLOW_DURATION * 0.5;
                ctx.fillStyle = `rgba(0, 255, 0, ${glowAlpha})`;
                ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
            }

            ctx.strokeStyle = '#00aa00';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            ctx.fillStyle = treeHealthRatio > 0.5 ? '#00FF00' : (treeHealthRatio > 0.2 ? '#FFD700' : '#FF0000');
            ctx.fillRect(barX, barY, barWidth * treeHealthRatio, barHeight);

            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(`ÃRBOL: ${tree.health}/${tree.maxHealth}`, W / 2, barY + barHeight + 20);

            // --- BARRA DE SALUD DE SANTA ---
            const santaHealthRatio = santa.health / santa.maxHealth;
            const santaBarWidth = 150;
            const santaBarHeight = 15;
            const santaBarX = W - santaBarWidth - 10;
            const santaBarY = 15;

            ctx.strokeStyle = 'white';
            ctx.strokeRect(santaBarX, santaBarY, santaBarWidth, santaBarHeight);

            ctx.fillStyle = santaHealthRatio > 0.5 ? '#00FF00' : (santaHealthRatio > 0.2 ? '#FFD700' : '#FF0000');
            ctx.fillRect(santaBarX, santaBarY, santaBarWidth * santaHealthRatio, santaBarHeight);

            ctx.fillStyle = 'white';
            ctx.textAlign = 'right';
            ctx.fillText(`Santa: ${santa.health}/${santa.maxHealth}`, W - 10, 30 + santaBarHeight + 5);
            
            
            // --- NUEVA: BARRA DE POWER-UP ---
            const powerUpRatio = Math.min(1, enemiesDefeatedSincePowerUp / ENEMIES_FOR_POWERUP);
            const powerBarWidth = 300;
            const powerBarHeight = 15;
            const powerBarX = W / 2 - powerBarWidth / 2;
            const powerBarY = H - 30; // Posicionada en la parte inferior

            // 1. Efecto Glitch FrenÃ©tico (Parpadeo y Desplazamiento)
            let glitchOffset = 0;
            let barColor = '#FF00FF'; // Color base (PÃºrpura/Magia)

            if (powerUpRatio === 1) {
                // Si la barra estÃ¡ llena, aplicamos el glitch visual
                glitchOffset = Math.random() * 6 - 3; // Desplazamiento horizontal aleatorio
                barColor = (Math.floor(gameFrame / 5) % 2 === 0) ? '#00FFFF' : '#FF00FF'; // Parpadeo cian/magenta

                // Aplicar filtro de color intenso al contexto *solo* para esta barra
                ctx.filter = `saturate(300%) hue-rotate(${Math.random() * 360}deg)`;
            } else {
                ctx.filter = 'none';
            }

            // Dibujar el Contorno de la Barra (con o sin glitch offset)
            ctx.strokeStyle = barColor;
            ctx.strokeRect(powerBarX + glitchOffset, powerBarY, powerBarWidth, powerBarHeight);

            // Dibujar la barra de progreso
            ctx.fillStyle = barColor;
            ctx.fillRect(powerBarX + glitchOffset, powerBarY, powerBarWidth * powerUpRatio, powerBarHeight);

            // Reiniciar el filtro despuÃ©s de dibujar la barra
            ctx.filter = 'none';

            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(`POWER UP: ${enemiesDefeatedSincePowerUp}/${ENEMIES_FOR_POWERUP} ENEMIGOS`, W / 2, powerBarY - 10);
            // ---------------------------------
            
            // DiÃ¡logo (esto ya estaba y va al final)
            if (dialogue.duration > 0) {
                drawDialogueBubble(santa.x, santa.y, dialogue.message);
            }
        }


        // --- 7. BUCLE PRINCIPAL Y RESET ---

        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, W, H);
            
            if (gameState === 'TITLE') {
                drawTitleScreen();
            } else if (gameState === 'PLAYING') {
                updateGame(deltaTime); 
                drawGameObjects();
            }

            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            if (backgroundMusicSource) {
                try { backgroundMusicSource.stop(); } catch (e) {}
                backgroundMusicSource = null;
            }
            
            santa.x = BASE_W / 2;
            santa.y = BASE_H / 2;
            santa.frame = 0;
            santa.health = santa.maxHealth;
            santa.invincible = false;
            santa.invincibleTimer = 0;
            santa.hitTimer = 0;
            tree.health = tree.maxHealth;
            tree.healingGlowTimer = 0; 
            tree.damageGlitchTimer = 0; 
            score = 0;
            lastHealScore = 0;
            enemies = [];
            bullets = [];
            explosions = []; 
            floatingTexts = [];
            enemiesDefeatedSincePowerUp = 0; 
            powerUpTimer = 0; 
            gameFrame = 0; 
            
            dialogue.message = "Â¡Feliz Navidad! O como lo llama el 1%, 'Temporada de Consumo Forzado'."; 
            dialogue.duration = PHRASE_DURATION;
            dialogue.powerUpMessage = null; 
            timeSinceLastPhrase = 0;
        }

        audioToggle.style.display = 'none';

        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
