<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EL SANTA DEFENDER</title>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: monospace;
            position: relative; /* Necesario para centrar el canvas y que los controles absolutos funcionen bien */
        }

        /* Estilo del Canvas Base (relación 800x600) */
        #gameCanvas {
            border: 4px solid #cc0000;
            background-color: #006600; 
            touch-action: none; 
            cursor: pointer; 
            /* Reglas Responsive */
            display: block;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
        }

        /* --- Controles Táctiles (Joystick) --- */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: none; 
            pointer-events: auto; /* Permite interacción */
        }

        .joystick-container {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            position: absolute;
            touch-action: none;
        }

        .action-button {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #cc0000;
            border: 5px solid #fff;
            color: #fff;
            font-size: 1.5em;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: auto;
            display: none; /* Inicialmente oculto */
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="controls" id="mobileControls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
    </div>
    <div class="action-button" id="shootButton">FUEGO</div>

    <script>
        // --- 1. CONFIGURACIÓN INICIAL Y DETECCIÓN ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_W = 800; // Ancho base del juego
        const BASE_H = 600; // Alto base del juego
        let W = BASE_W; 
        let H = BASE_H;
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Estados del Juego
        let gameState = 'TITLE'; // 'TITLE' o 'PLAYING'

        // Referencias a los controles móviles
        const controls = document.getElementById('mobileControls');
        const shootButton = document.getElementById('shootButton');
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');

        // Constantes del juego
        const PLAYER_SPEED = 4;
        const BULLET_SPEED = 8;
        const JOYSTICK_RADIUS = 75; 
        const PHRASE_DURATION = 300; 
        const PHRASE_INTERVAL = 8000; 
        
        // --- POWER-UP CONSTANTES ---
        const ENEMIES_FOR_POWERUP = 10;
        const POWERUP_DURATION = 300; 
        
        // --- TIPOS DE ENEMIGOS (Velocidad Variable) ---
        const ENEMY_TYPES = [
            { speed: 1.5, color: '#666666', spawnWeight: 60 }, // Lento y común (60%)
            { speed: 2.5, color: '#990000', spawnWeight: 30 }, // Rápido (30%)
            { speed: 1.0, color: '#000066', spawnWeight: 10 }  // Tanque (Lento, 10%)
        ];
        let spawnRate = 0.02; // Probabilidad de spawn por frame

        // --- 2. OBJETOS DEL JUEGO Y ESTADO ---
        let santa = {
            x: BASE_W / 2,
            y: BASE_H / 2,
            size: 20, 
            color: 'red',
            health: 10,
            maxHealth: 10, // NUEVO: Máxima salud de Santa
            dirX: 0,
            dirY: 0,
            shooting: false,
            lastShotTime: 0,
            fireRate: 200,
            frame: 0,
            invincible: false, // NUEVO: Estado de invencibilidad
            invincibleTimer: 0 // NUEVO: Contador de invencibilidad
        };

        const tree = {
            x: BASE_W / 2,
            y: BASE_H / 2,
            size: 40,
            color: '#00aa00', 
            health: 50
        };

        let bullets = [];
        let enemies = [];
        let explosions = []; 
        let score = 0;
        let enemiesDefeatedSincePowerUp = 0; 
        let powerUpTimer = 0; 
        const treeHealthMax = 50;
        
        let dialogue = {
            message: "¡Feliz Navidad, mis pequeños capitalistas!",
            duration: PHRASE_DURATION 
        };

        const invincibilityPhrase = "¡Soy invencible, ¡Fuera de aqui capitalistas!";
        const sarcasticPhrases = [
            { min: 40, phrases: ["¡No me cansaré hasta que mis nietos hereden el negocio!", "¡Este traje es heredado, no lo ensucies!", "¡El valor de mercado de este pino es astronómico!", "¡Estos muchachos son peores que el tráfico en Black Friday!", "¡La codicia no los hace inmortales, chicos!"] },
            { min: 25, phrases: ["¿De verdad? ¿Solo un arbolito? ¡Qué falta de ambición!", "¡Un poco de dolor hará que aprecien más la Navidad.", "¡Pagaría por un café con estos niveles de adrenalina!", "¡Mis elfos son fuerza de trabajo organizada!", "¡Deberían estar invirtiendo en protección, no en deforestación!"] },
            { min: 1, phrases: ["¡Parece que vamos a necesitar un plan B... o un nuevo árbol!", "¡Mi seguro de vida cubre esto, ¿verdad?!", "¡Alguien va a pasar la Navidad en la lista negra!", "¡Si sobrevivo, subiré el precio de los juguetes en un 200%!", "¡Al menos es mejor que la reunión de la junta directiva de enero!"] }
        ];

        let timeSinceLastPhrase = 0;

        // --- CLASE EXPLOSIÓN (Sin cambios) ---
        class Explosion {
            constructor(x, y, color) {
                this.particles = [];
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        size: Math.random() * 4 + 2, 
                        color: color,
                        vx: Math.random() * 6 - 3, 
                        vy: Math.random() * 6 - 3, 
                        life: 30 
                    });
                }
            }
            update() {
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                });
                this.particles = this.particles.filter(p => p.life > 0);
                return this.particles.length > 0;
            }
            draw() {
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                });
            }
        }
        
        // --- 3. RESPONSIVE DESIGN Y MANEJO DE VENTANA ---

        function resizeGame() {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const aspectR = BASE_W / BASE_H;
            
            let newW, newH;

            if (viewportW / viewportH > aspectR) {
                newH = viewportH;
                newW = viewportH * aspectR;
            } else {
                newW = viewportW;
                newH = viewportW / aspectR;
            }
            
            canvas.style.width = newW + 'px';
            canvas.style.height = newH + 'px';

            W = BASE_W;
            H = BASE_H;
            canvas.width = W;
            canvas.height = H;
        }

        window.addEventListener('resize', resizeGame);
        resizeGame();


        // --- 4. MANEJO DE EVENTOS (Título y Controles) ---
        
        function handleStartGame() {
            if (gameState === 'TITLE') {
                gameState = 'PLAYING';
                resetGame();
                if (isMobile) {
                    controls.style.display = 'block';
                    shootButton.style.display = 'flex';
                }
            }
        }

        canvas.addEventListener('mousedown', handleStartGame);
        canvas.addEventListener('touchstart', (e) => {
            if (gameState === 'TITLE') {
                e.preventDefault();
                handleStartGame();
            }
        });
        
        // --- Controles de juego (Joystick y Teclado) ---
        let keys = {};
        if (!isMobile) {
            window.addEventListener('keydown', (e) => {
                if (gameState === 'PLAYING') keys[e.code] = true;
            });
            window.addEventListener('keyup', (e) => {
                if (gameState === 'PLAYING') keys[e.code] = false;
                if (e.code === 'Space' && gameState === 'PLAYING') santa.shooting = false;
            });
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = true;
            });
            window.addEventListener('mouseup', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = false;
            });
        }
        
        let joystickActive = false;
        let startX, startY;

        if (isMobile) {
            joystickContainer.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            });
            joystickContainer.addEventListener('touchmove', (e) => {
                if (!joystickActive || gameState !== 'PLAYING') return;
                const touch = e.touches[0];
                let deltaX = touch.clientX - startX;
                let deltaY = touch.clientY - startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > JOYSTICK_RADIUS) {
                    deltaX = (deltaX / distance) * JOYSTICK_RADIUS;
                    deltaY = (deltaY / distance) * JOYSTICK_RADIUS;
                }
                joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                santa.dirX = deltaX / JOYSTICK_RADIUS;
                santa.dirY = deltaY / JOYSTICK_RADIUS;
            });
            const resetJoystick = () => {
                joystickActive = false;
                santa.dirX = 0;
                santa.dirY = 0;
                joystickHandle.style.transform = `translate(0px, 0px)`;
            };
            joystickContainer.addEventListener('touchend', resetJoystick);
            joystickContainer.addEventListener('touchcancel', resetJoystick);

            shootButton.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = true;
            });
            shootButton.addEventListener('touchend', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = false;
            });
        }


        // --- 5. LÓGICA DEL JUEGO (UPDATE) ---

        function handleShooting(deltaTime) {
            const currentFireRate = (santa.invincibleTimer > 0) ? 50 : santa.fireRate;
            
            if ((!isMobile && (keys['Space'] || santa.shooting)) || (isMobile && santa.shooting) || (santa.invincibleTimer > 0)) {
                const currentTime = Date.now();
                if (currentTime - santa.lastShotTime > currentFireRate) {
                    const dx = tree.x - santa.x;
                    const dy = tree.y - santa.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const nx = dx / dist;
                    const ny = dy / dist;

                    bullets.push({
                        x: santa.x,
                        y: santa.y,
                        size: (santa.invincibleTimer > 0) ? 12 : 8,
                        color: (santa.invincibleTimer > 0) ? '#00FFFF' : 'yellow',
                        dirX: nx,
                        dirY: ny
                    });
                    santa.lastShotTime = currentTime;
                }
            }
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.dirX * BULLET_SPEED;
                bullet.y += bullet.dirY * BULLET_SPEED;

                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        explosions.push(new Explosion(enemy.x, enemy.y, enemy.color)); 
                        
                        enemies.splice(j, 1); 
                        bullets.splice(i, 1); 
                        score += 10;
                        enemiesDefeatedSincePowerUp++;
                        
                        hit = true;
                        break;
                    }
                }

                if (!hit && (bullet.x < 0 || bullet.x > W || bullet.y < 0 || bullet.y > H)) {
                    bullets.splice(i, 1);
                }
            }
        }
        
        function updatePowerUp(deltaTime) {
            // Invencibilidad y Power-Up
            if (santa.invincibleTimer > 0) {
                santa.invincibleTimer -= (deltaTime / (1000 / 60)); 
                if (santa.invincibleTimer <= 0) {
                    santa.invincible = false;
                    santa.invincibleTimer = 0;
                    dialogue.message = "¡Se agotó la invencibilidad!";
                    dialogue.duration = PHRASE_DURATION;
                }
            }
            
            if (enemiesDefeatedSincePowerUp >= ENEMIES_FOR_POWERUP) {
                // El power-up ahora RELLENA LA SALUD de Santa
                santa.health = santa.maxHealth; 
                
                // Activa la invencibilidad
                santa.invincible = true;
                santa.invincibleTimer = POWERUP_DURATION; 
                
                enemiesDefeatedSincePowerUp = 0; 
                dialogue.message = invincibilityPhrase;
                dialogue.duration = PHRASE_DURATION;
            }
        }

        function updatePlayerMovement() {
            if (!isMobile) {
                santa.dirX = 0;
                santa.dirY = 0;
                if (keys['KeyA'] || keys['ArrowLeft']) santa.dirX = -1;
                if (keys['KeyD'] || keys['ArrowRight']) santa.dirX = 1;
                if (keys['KeyW'] || keys['ArrowUp']) santa.dirY = -1;
                if (keys['KeyS'] || keys['ArrowDown']) santa.dirY = 1;
            }
            const magnitude = Math.sqrt(santa.dirX * santa.dirX + santa.dirY * santa.dirY);
            if (magnitude > 0) {
                const nx = santa.dirX / magnitude;
                const ny = santa.dirY / magnitude;
                santa.x += nx * PLAYER_SPEED;
                santa.y += ny * PLAYER_SPEED;
                santa.frame = (santa.frame + 0.1) % 2; 
                santa.x = Math.max(santa.size / 2, Math.min(W - santa.size / 2, santa.x));
                santa.y = Math.max(santa.size / 2, Math.min(H - santa.size / 2, santa.y));
            } else {
                 santa.frame = 0; 
            }
        }
        function updateExplosions() {
             for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function spawnEnemies() {
            if (Math.random() < spawnRate) { 
                
                // Lógica de selección de enemigo por peso
                let totalWeight = ENEMY_TYPES.reduce((sum, type) => sum + type.spawnWeight, 0);
                let randomValue = Math.random() * totalWeight;
                let selectedType = ENEMY_TYPES[0];

                for (const type of ENEMY_TYPES) {
                    randomValue -= type.spawnWeight;
                    if (randomValue <= 0) {
                        selectedType = type;
                        break;
                    }
                }

                const size = 15;
                const edge = Math.floor(Math.random() * 4); 
                let x, y;
                switch (edge) {
                    case 0: x = Math.random() * W; y = -size; break;
                    case 1: x = W + size; y = Math.random() * H; break;
                    case 2: x = Math.random() * W; y = H + size; break;
                    case 3: x = -size; y = Math.random() * H; break;
                }
                
                enemies.push({ 
                    x: x, 
                    y: y, 
                    size: size, 
                    color: selectedType.color,
                    speed: selectedType.speed // Velocidad individual
                });
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = tree.x - enemy.x;
                const dy = tree.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / dist;
                const ny = dy / dist;
                
                // Mover enemigo con su velocidad individual
                enemy.x += nx * enemy.speed; 
                enemy.y += ny * enemy.speed;
                
                let destroyed = false;

                // LÓGICA DE DAÑO A SANTA CON INVENCIBILIDAD
                if (checkCollision(enemy, santa)) {
                    if (!santa.invincible) { // Solo recibe daño si NO es invencible
                        santa.health -= 1;
                        explosions.push(new Explosion(enemy.x, enemy.y, 'white'));
                        
                        if (santa.health <= 0) {
                            alert('GAME OVER! Santa ha sido sobrepasado. Puntuación: ' + score);
                            gameState = 'TITLE';
                            resetGame();
                            if (isMobile) {
                                controls.style.display = 'none';
                                shootButton.style.display = 'none';
                            }
                            return; 
                        }
                    } else {
                        // Si es invencible, solo hay una explosión visual al contacto
                        explosions.push(new Explosion(enemy.x, enemy.y, '#FF00FF'));
                    }

                    // El enemigo siempre se destruye al colisionar con Santa
                    enemies.splice(i, 1);
                    destroyed = true;
                }
                
                // Lógica de daño al Árbol (Solo si no ha sido destruido al dañar a Santa)
                if (!destroyed && checkCollision(enemy, tree)) {
                    tree.health -= 1;
                    enemies.splice(i, 1);
                    
                    if (tree.health <= 0) {
                        alert('GAME OVER! El árbol ha sido talado. Puntuación: ' + score);
                        gameState = 'TITLE'; 
                        resetGame(); 
                        if (isMobile) {
                            controls.style.display = 'none';
                            shootButton.style.display = 'none';
                        }
                        return;
                    }
                }
            }
        }
        
        function updateDialogue(deltaTime) {
            if (dialogue.duration > 0) {
                dialogue.duration -= (deltaTime / (1000 / 60)); 
            }
            timeSinceLastPhrase += deltaTime;
            if (timeSinceLastPhrase > PHRASE_INTERVAL && dialogue.duration <= 0) {
                let eligiblePhrases = [];
                for(const group of sarcasticPhrases) {
                    if (tree.health >= group.min) {
                        eligiblePhrases = group.phrases;
                        break;
                    }
                }
                if (eligiblePhrases.length > 0) {
                    const newPhrase = eligiblePhrases[Math.floor(Math.random() * eligiblePhrases.length)];
                    dialogue.message = newPhrase;
                    dialogue.duration = PHRASE_DURATION; 
                    timeSinceLastPhrase = 0;
                }
            }
        }
        function checkCollision(objA, objB) {
            // Esta función maneja la colisión entre Santa/Enemigo/Árbol. 
            // Para Santa y Enemigos, usan 'size'. Para Árbol, usa 'size' también.
            return objA.x < objB.x + objB.size && objA.x + objA.size > objB.x &&
                   objA.y < objB.y + objB.size && objA.y + objB.size > objB.y;
        }


        function updateGame(deltaTime) {
            updatePlayerMovement();
            updatePowerUp(deltaTime); 
            handleShooting(deltaTime);
            updateBullets();
            updateExplosions(); 
            spawnEnemies();
            updateEnemies();
            updateDialogue(deltaTime); 
        }

        // --- 6. RENDERIZADO (DRAW) ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x - w / 2, y - h / 2, w, h);
        }
        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSanta(x, y, size, frame) {
            // NUEVO: Efecto de parpadeo si es invencible
            if (santa.invincible && Math.floor(santa.invincibleTimer / 5) % 2 === 0) {
                return; // Ocultar el sprite para un efecto de parpadeo
            }

            const legOffset = (Math.floor(frame) === 0) ? 3 : -3;
            drawRect(x, y, size, size, 'red');
            drawRect(x, y + 4, size, size / 2, 'white'); 
            drawRect(x, y - 8, size / 2, size / 2, 'white'); 
            drawRect(x, y - 10, size, size / 3, 'red'); 
            drawRect(x - 5, y - 2, 3, 3, 'black');
            drawRect(x + 5, y - 2, 3, 3, 'black');
            drawRect(x - 5 + legOffset, y + 8, 4, 4, 'black');
            drawRect(x + 5 - legOffset, y + 8, 4, 4, 'black');
        }

        function drawTitleText(x, y, message, fontSize, color, align = 'center') {
            ctx.fillStyle = color;
            ctx.font = `${fontSize}px monospace`;
            ctx.textAlign = align;
            ctx.fillText(message, x, y);
        }

        function drawTitleScreen() {
            ctx.fillStyle = '#003300';
            ctx.fillRect(0, 0, W, H);

            drawTitleText(W / 2, H / 2 - 150, "EL SANTA DEFENDER", 60, '#cc0000');
            drawTitleText(W / 2, H / 2 - 80, "La Lucha Contra la Codicia", 24, 'white');
            drawSanta(W / 4, H / 2 + 50, 40, 0); 
            drawTitleText(W / 4, H / 2 + 100, "Santa", 20, 'white');
            
            const instructions = isMobile ? 
                ["**MOVIL**:", "Joystick Izq: Mover", "Botón FUEGO: Disparar", "Toca la pantalla para JUGAR"] :
                ["**PC**:", "WASD / Flechas: Mover", "Espacio / Click: Disparar", "Click en la pantalla para JUGAR"];
            
            let lineY = H / 2 - 50;
            const lineX = W * 0.6;

            instructions.forEach(line => {
                const color = line.startsWith('**') ? '#ffcc00' : 'white';
                const text = line.replace(/\*\*/g, '');
                drawTitleText(lineX, lineY, text, 20, color, 'left'); 
                lineY += 30;
            });

            drawTitleText(W / 2, H - 50, "¡La Navidad depende de ti!", 24, '#00aa00');
        }

        function applyPsychedelicGlitch() {
            ctx.translate(Math.random() * 4 - 2, Math.random() * 4 - 2); 
            if (Math.random() < 0.5) {
                ctx.globalAlpha = 0.8;
                ctx.filter = `hue-rotate(${Math.random() * 360}deg) saturate(200%)`;
            } else {
                 ctx.filter = 'none';
                 ctx.globalAlpha = 1;
            }
        }
        
        function drawGameObjects() {
            if (santa.invincibleTimer > 0) {
                applyPsychedelicGlitch();
            } else {
                ctx.filter = 'none';
                ctx.globalAlpha = 1;
            }
            
            const titleText = "EL SANTA DEFENDER";
            const fontSize = 48; 
            const titleColor = '#004d00'; 
            ctx.fillStyle = titleColor;
            ctx.font = `${fontSize}px monospace`;
            ctx.textAlign = 'center';
            const titleY = H / 2 + fontSize * 1.5;
            ctx.fillText(titleText, W / 2 + 2, titleY + 2);
            ctx.fillText(titleText, W / 2 - 2, titleY - 2);
            ctx.fillText(titleText, W / 2, titleY);

            drawTree();
            drawEnemies();
            drawBullets();
            drawSanta(santa.x, santa.y, santa.size, santa.frame); 
            explosions.forEach(exp => exp.draw());
            drawHUD();
            
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.filter = 'none';
            ctx.globalAlpha = 1;

            if (santa.invincibleTimer > 0) {
                ctx.fillStyle = '#FF00FF';
                const barWidth = 300 * (santa.invincibleTimer / POWERUP_DURATION);
                ctx.fillRect(W / 2 - 150, H - 25, barWidth, 15);
                drawTitleText(W/2, H-10, "INVENCIBLE", 16, '#FF00FF');
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                const barWidth = 300 * (enemiesDefeatedSincePowerUp / ENEMIES_FOR_POWERUP);
                ctx.fillRect(W / 2 - 150, H - 25, barWidth, 15);
                drawTitleText(W/2, H-10, `Racha: ${enemiesDefeatedSincePowerUp}/${ENEMIES_FOR_POWERUP}`, 16, 'white');
            }
        }
        
        function drawTree() {
            drawRect(tree.x, tree.y + tree.size / 2 - 5, 10, 10, '#8B4513');
            ctx.fillStyle = tree.color;
            ctx.beginPath();
            ctx.moveTo(tree.x, tree.y - tree.size); 
            ctx.lineTo(tree.x - tree.size, tree.y + tree.size / 2);
            ctx.lineTo(tree.x + tree.size, tree.y + tree.size / 2);
            ctx.closePath();
            ctx.fill();
            drawCircle(tree.x - 10, tree.y - 15, 3, 'yellow');
            drawCircle(tree.x + 15, tree.y, 3, 'red');
            drawCircle(tree.x - 5, tree.y + 10, 3, 'blue');
            ctx.fillStyle = 'white';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`HP: ${tree.health}`, tree.x, tree.y + tree.size + 10);
        }

        function drawEnemies() {
            enemies.forEach(e => {
                drawRect(e.x, e.y, e.size, e.size, e.color);
                drawRect(e.x + e.size / 4, e.y + e.size / 4, e.size / 3, e.size / 3, 'black'); 
            });
        }
        function drawBullets() {
            bullets.forEach(b => {
                drawRect(b.x, b.y, b.size, b.size, b.color);
            });
        }
        
        function drawDialogueBubble(x, y, message) {
            const padding = 10;
            ctx.font = '16px monospace';
            const textMetrics = ctx.measureText(message);
            const textWidth = textMetrics.width;
            const textHeight = 16;
            const bubbleW = textWidth + padding * 2;
            const bubbleH = textHeight + padding * 2;
            const bubbleX = x - bubbleW / 2;
            const bubbleY = y - santa.size - bubbleH - 5; 
            ctx.fillStyle = 'white';
            ctx.fillRect(bubbleX, bubbleY, bubbleW, bubbleH);
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.fillText(message, x, bubbleY + textHeight + padding - 2);
        }

        function drawHUD() {
            ctx.fillStyle = 'white';
            ctx.font = '20px monospace';
            
            // Puntuación
            ctx.textAlign = 'left';
            ctx.fillText(`Puntuación: ${score}`, 10, 30);
            
            // Salud Santa (Esquina superior derecha) - AHORA CON BARRA
            const healthRatio = santa.health / santa.maxHealth;
            const barWidth = 150;
            const barHeight = 15;
            const barX = W - barWidth - 10;
            const barY = 15;

            ctx.strokeStyle = 'white';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            ctx.fillStyle = healthRatio > 0.5 ? '#00FF00' : (healthRatio > 0.2 ? '#FFD700' : '#FF0000');
            ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);

            ctx.fillStyle = 'white';
            ctx.textAlign = 'right';
            ctx.fillText(`Santa: ${santa.health}/${santa.maxHealth}`, W - 10, 30);
            
            // Diálogo (si está activo, encima de Santa)
            if (dialogue.duration > 0) {
                drawDialogueBubble(santa.x, santa.y, dialogue.message);
            }
        }


        // --- 7. BUCLE PRINCIPAL Y RESET ---

        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, W, H);
            
            if (gameState === 'TITLE') {
                drawTitleScreen();
            } else if (gameState === 'PLAYING') {
                updateGame(deltaTime); 
                drawGameObjects();
            }

            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            santa.x = BASE_W / 2;
            santa.y = BASE_H / 2;
            santa.frame = 0;
            santa.health = santa.maxHealth; // REINICIAR SALUD DE SANTA
            santa.invincible = false; // RESET INVENCIBILIDAD
            santa.invincibleTimer = 0; // RESET TIMER
            tree.health = treeHealthMax; 
            score = 0;
            enemies = [];
            bullets = [];
            explosions = []; 
            enemiesDefeatedSincePowerUp = 0; 
            powerUpTimer = 0; 
            dialogue.message = "¡Feliz Navidad, mis pequeños capitalistas!";
            dialogue.duration = PHRASE_DURATION;
            timeSinceLastPhrase = 0;
        }

        // Iniciar el bucle de juego
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
