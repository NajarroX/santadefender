<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EL SANTA DEFENDER</title>

    <style>
        /* --- FUENTES DE GOOGLE (Para t√≠tulo grueso y retro) --- */
        @import url('https://fonts.googleapis.com/css2?family=Bungee+Inline&family=Press+Start+2P&display=swap');

        /* --- ESTILOS BASE y AJUSTE DE VIEWPORT (Clave para eliminar scroll) --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #006600;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            /* CLAVE: Usamos 100dvh para respetar las barras de navegaci√≥n de los in-app browsers */
            height: 100dvh;
            font-family: 'Press Start 2P', monospace;
            position: relative;
        }

        /* --- PATR√ìN DE FONDO ANIMADO --- */
        .background-pattern {
            position: fixed;
            top: 0;
            left: 0;
            width: 300%;
            height: 300%;
            z-index: 1;
            background:
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 40px,
                    rgba(0, 0, 0, 0.1) 40px,
                    rgba(0, 0, 0, 0.1) 80px
                ),
                repeating-linear-gradient(
                    -45deg,
                    #004d00,
                    #004d00 30px,
                    #00aa00 30px,
                    #00aa00 60px
                );
            background-size: 150px 150px, 150px 150px;
            animation: movePattern 20s linear infinite;
        }

        .background-pattern.paused {
            animation-play-state: paused;
        }

        @keyframes movePattern {
            from { background-position: 0 0, 0 0; }
            to { background-position: 150px 150px, 150px 150px; }
        }

        /* --- T√çTULO PRINCIPAL (AHORA FIJO AL TOP) --- */
        #mainTitle {
            font-family: 'Bungee Inline', sans-serif;
            color: white;
            text-align: center;
            line-height: 0.8;
            z-index: 30;
            text-shadow:
                -5px -5px 0 #000, 5px -5px 0 #000, -5px 5px 0 #000, 5px 5px 0 #000,
                0 0 10px #FF0000;

            position: fixed;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            font-size: 80px;
        }

        /* Contenedor principal que centra el canvas */
        #gameContainer {
            position: relative;
            z-index: 10;
            border: 4px solid #cc0000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);

            width: 800px;
            height: 600px;
            max-width: 98vw;
            max-height: 98vh;

            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Estilo del Canvas Base */
        #gameCanvas {
            background-color: rgba(0, 102, 0, 0.85);
            touch-action: none;
            cursor: pointer;
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- Contenedor de elementos HTML de la Portada (ABSOLUTE EN EL BODY) --- */
        .title-elements-container {
            /* CLAVE: Posici√≥n absoluta en el body */
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            /* CLAVE: min-height: 100% para cubrir el body (que usa 100dvh) */
            min-height: 100%;
            z-index: 20;

            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Dejamos que el spacer empuje */
            align-items: center;
            pointer-events: none;

            padding: 5vh 0 0;
        }

        /* Espaciador */
        #characterAreaSpacer {
            flex-grow: 1;
            width: 100%;
        }

        /* Contenedor para el Bot√≥n y las Instrucciones */
        #controlArea {
            pointer-events: auto;
            /* CLAVE: Usamos posici√≥n absoluta para forzar el bottom en el viewport */
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            /* CLAVE: Espacio de 40px de la orilla inferior en PC/Grande */
            bottom: 40px;
        }

        /* --- Estilos del Bot√≥n de Inicio --- */
        #startButton {
            pointer-events: auto;
            padding: 15px 30px;
            font-size: 30px;
            font-weight: bold;
            color: #FFFF00;
            background-color: #CC0000;
            border: 5px solid #000;
            box-shadow: 0 5px 0 #FF3333, 0 8px 0 #990000;
            cursor: pointer;
            text-align: center;
            margin-bottom: 15px;
            line-height: 1;
            user-select: none;
            font-family: 'Press Start 2P', monospace;
            z-index: 20;
            transition: all 0.1s ease;
        }

        #startButton:active {
            box-shadow: 0 2px 0 #FF3333, 0 5px 0 #990000;
            transform: translateY(3px);
        }

        /* --- Bloque de Instrucciones --- */
        #instructions {
            pointer-events: auto;
            position: static;
            width: 600px;
            max-width: 85%;
            padding: 10px;
            background: rgba(34, 34, 34, 0.9);
            border: 3px solid #FFD700;
            color: #FFD700;
            z-index: 20;
            font-size: 14px;
            line-height: 1.5;
            text-align: center;
            margin-bottom: 15px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
        }

        #instructions h3 {
            margin-top: 0;
            color: #CC0000;
            font-size: 16px;
            border-bottom: 1px dashed #CC0000;
            padding-bottom: 5px;
        }

        #instructions p {
            margin: 5px 0;
            text-shadow: 1px 1px 2px black;
        }


        /* --- RESPONSIVE GENERAL (Max 800px) --- */
        @media (max-width: 800px) {
            #mainTitle {
                font-size: 40px;
                top: 20px;
                text-shadow:
                    -3px -3px 0 #000, 3px -3px 0 #000, -3px 3px 0 #000, 3px 3px 0 #000,
                    0 0 8px #FF0000;
            }

            .title-elements-container {
                padding: 2vh 0 0;
            }

            #controlArea {
                /* CLAVE: Espacio de 30px de la orilla inferior en tablet/m√≥vil horizontal */
                bottom: 30px;
            }

            #startButton {
                font-size: 20px;
                padding: 10px 20px;
                box-shadow: 0 4px 0 #FF3333, 0 6px 0 #990000;
            }

            #instructions {
                font-size: 10px;
                max-width: 90%;
            }
            #instructions h3 {
                font-size: 14px;
            }

            /* Ajuste de AudioToggle en m√≥vil */
            #audioToggle {
                font-size: 16px;
                padding: 5px 8px;
            }
        }

        /* --- CLAVE: AJUSTES ESPEC√çFICOS PARA M√ìVIL VERTICAL (pantallas muy estrechas/altas) --- */
        @media (max-width: 600px) and (max-height: 800px) {

            #mainTitle {
                font-size: 32px;
                top: 10px;
            }

            .title-elements-container {
                padding: 1vh 0 0;
            }

            #controlArea {
                /* CLAVE: Espacio de 20px en m√≥vil vertical para m√°xima seguridad */
                bottom: 20px;
            }

            #instructions {
                padding: 5px;
                font-size: 9px;
            }
            #instructions h3 {
                font-size: 12px;
            }

            /* Ajuste de AudioToggle en m√≥vil vertical */
            #audioToggle {
                font-size: 14px;
                padding: 4px 6px;
            }
        }

        /* --- Control de Audio y Controles T√°ctiles (Mejora Visual) --- */

        /* --- Control de Audio --- */
        #audioToggle {
            position: fixed;
            top: 15px; /* M√°s espacio arriba */
            left: 15px; /* M√°s espacio a la izquierda */
            z-index: 40;

            /* Nuevo Estilo Retro */
            background: #000;
            color: #FFD700; /* Oro */
            border: 4px solid #CC0000; /* Borde rojo grueso */
            box-shadow: 0 0 10px #FF0000; /* Brillo */
            border-radius: 0; /* Cuadrado */

            padding: 8px 12px;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            display: none;
            pointer-events: auto;
            font-family: 'Press Start 2P', monospace; /* Aplicamos la fuente retro */
        }

        #audioToggle:active {
            transform: scale(0.95);
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 40;
            display: none;
            pointer-events: auto;
        }

        .joystick-container {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            /* Estilo Retro - M√°s s√≥lido y brillante */
            background-color: rgba(34, 34, 34, 0.7); /* Gris oscuro */
            border: 3px solid #FFD700;
            box-shadow: inset 0 0 10px rgba(255, 255, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            /* Estilo Retro - Mango llamativo */
            background-color: #CC0000;
            border: 4px solid #FFD700;
            position: absolute;
            touch-action: none;
            box-shadow: 0 0 5px #FFFFFF;
        }

        .action-button {
            position: fixed;
            bottom: 50px;
            right: 50px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            /* Estilo Retro */
            background-color: #00FFFF; /* CIAN - Color de disparo */
            border: 5px solid #000;
            color: #000;
            font-size: 1.2em;
            font-family: 'Press Start 2P', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 15px #00FFFF, inset 0 0 5px #FFFFFF;
            pointer-events: auto;
            display: none;
            z-index: 40;
        }

        .action-button:active {
            transform: scale(0.9);
            box-shadow: 0 0 5px #00FFFF, inset 0 0 5px #FFFFFF;
        }
    </style>
</head>
<body>
    <div class="background-pattern" id="backgroundPattern"></div>

    <h1 id="mainTitle">EL SANTA<br>DEFENDER</h1>

    <div class="title-elements-container" id="titleElementsContainer">

        <div id="characterAreaSpacer">
        </div>

        <div id="controlArea">
            <div id="instructions">
            </div>
            <div id="startButton">
                ¬°A DEFENDER!
            </div>
        </div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>

    <button id="audioToggle">üîä</button>

    <div class="controls" id="mobileControls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
    </div>
    <div class="action-button" id="shootButton">FUEGO</div>


    <script>
        // --- 1. CONFIGURACI√ìN INICIAL Y DETECCI√ìN ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_W = 800;
        const BASE_H = 600;
        let W = BASE_W;
        let H = BASE_H;
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Estados del Juego
        let gameState = 'TITLE';

        // Referencias a los nuevos elementos de la portada
        const mainTitle = document.getElementById('mainTitle');
        const startButton = document.getElementById('startButton');
        const instructionsDiv = document.getElementById('instructions');
        const gameContainer = document.getElementById('gameContainer');
        const titleElementsContainer = document.getElementById('titleElementsContainer');
        const backgroundPattern = document.getElementById('backgroundPattern');

        // Referencias a los controles y el bot√≥n de audio
        const controls = document.getElementById('mobileControls');
        const shootButton = document.getElementById('shootButton');
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const audioToggle = document.getElementById('audioToggle');

        // Constantes del juego (se mantienen)
        const PLAYER_SPEED = 4;
        const BULLET_SPEED = 8;
        const JOYSTICK_RADIUS = 75;
        const PHRASE_DURATION = 300;
        const PHRASE_INTERVAL = 8000;
        const HIT_DURATION = 10;
        const GLITCH_DURATION = 15;
        const ENEMIES_FOR_POWERUP = 10;
        const POWERUP_DURATION = 300;
        const INVINCIBILITY_PHRASE_DURATION = 90;
        const INVINCIBILITY_PHRASE_CHANCE = 0.40;
        const ENEMY_TYPES = [
            { speed: 1.5, color: '#666666', spawnWeight: 60 },
            { speed: 2.5, color: '#990000', spawnWeight: 30 },
            { speed: 1.0, color: '#000066', spawnWeight: 10 }
        ];
        let spawnRate = 0.02;
        const HEAL_SCORE_HIT = 1000;
        let lastHealScore = 0;
        const GLOW_DURATION = 30;
        
        // NUEVO: Constantes para la BOMBA
        const BOMBA_SCORE_HIT = 500;
        const BOMBA_DURATION = 300; // 5 segundos a 60 FPS
        const BOMBA_SIZE = 25;

        // Objetos del juego (se mantienen)
        let santa = {
            x: BASE_W / 2, y: BASE_H / 2, size: 20, color: 'red', health: 10, maxHealth: 10, dirX: 0, dirY: 0, shooting: false, lastShotTime: 0, fireRate: 200, frame: 0, invincible: false, invincibleTimer: 0, hitTimer: 0
        };
        const ENEMY_BASE_SIZE = 18;
        let tree = {
            x: BASE_W / 2, y: BASE_H / 2, size: 40, color: '#00aa00', health: 50, maxHealth: 50, healingGlowTimer: 0, damageGlitchTimer: 0
        };
        const treeHealthMax = tree.maxHealth;
        let bullets = [];
        let enemies = [];
        let explosions = [];
        let floatingTexts = [];
        let score = 0;
        let enemiesDefeatedSincePowerUp = 0;
        let powerUpTimer = 0;
        let gameFrame = 0;
        let dialogue = {
            message: "¬°Feliz Navidad! O como lo llama el 1%, 'Temporada de Consumo Forzado'.",
            duration: PHRASE_DURATION, powerUpMessage: null
        };
        const invincibilityPhrases = [
            "¬°Fuera de aqu√≠, par√°sitos capitalistas!", "¬°El capital no puede con la magia de un Santa sindicalizado!", "¬°El √∫nico regalo que dar√© es esta paliza! ¬°Por un Polo Norte libre de explotaci√≥n!"
        ];
        const sarcasticPhrases = [
            { min: 40, phrases: [
                "¬°Luchando por el √°rbol, el √∫nico bien p√∫blico que queda en pie!",
                "¬°Mis elfos no tienen sindicato, son la verdadera tragedia aqu√≠, no estos demonios!", "¬°La avaricia ha creado monstruos... literalmente! ¬°Que iron√≠a!", "¬°El precio de la hora extra es lo que realmente duele, no sus mordiscos!", "¬°Defender este √°rbol es la nueva 'responsabilidad social corporativa'!"
            ] },
            { min: 25, phrases: [
                "¬øEn serio? ¬øTantos enemigos y la riqueza sigue concentrada en los de arriba?", "¬°Esto es lo que pasa cuando privatizas el Polo Norte!", "¬°No hay suficientes incentivos fiscales para seguir con esta masacre!", "¬°Al menos estos monstruos trabajan, a diferencia de los par√°sitos de la junta directiva!", "¬°Mi n√≥mina est√° congelada, pero mi furia no!"
            ] },
            { min: 1, phrases: [
                "¬°La recesi√≥n de salud lleg√≥ antes de lo esperado! ¬°S√°lvese quien pueda!", "¬°Parece que el mercado se est√° 'ajustando' a la baja, justo como mi moral!", "¬°Si perdemos, que el √°rbol se declare en bancarrota para salvar mis activos!", "¬°La pr√≥xima Navidad, los juguetes ser√°n hechos por la IA... y ser√°n a√∫n m√°s caros!", "¬°El verdadero regalo es un sistema que funcione, no m√°s juguetes!"
            ] }
        ];
        let timeSinceLastPhrase = 0;
        
        // NUEVO: Variables para la BOMBA
        let bomba = {
            active: false,
            x: 0,
            y: 0,
            timer: 0,
            frame: 0
        };
        let lastBombaScore = 0;

        // Audio (se mantiene)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        let isMuted = false;
        let backgroundMusicSource = null;
        const C4 = 261.63, D4 = 293.66, E4 = 329.63, F4 = 349.23, G4 = 392.00, A4 = 440.00;
        const tempo = 0.25;
        const melody = [
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: C4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: E4, duration: 2.0 },
            { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 },
            { freq: F4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.25 }, { freq: D4, duration: 0.25 },
            { freq: D4, duration: 0.5 }, { freq: D4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: G4, duration: 2.0 },
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: C4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: E4, duration: 2.0 },
            { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 },
            { freq: F4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.25 }, { freq: D4, duration: 0.25 },
            { freq: G4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: C4, duration: 2.0 }
        ];

        function startBackgroundMusic() {
            if (backgroundMusicSource) {
                if (backgroundMusicSource.playbackState === backgroundMusicSource.PLAYING_STATE) {
                    try { backgroundMusicSource.stop(audioContext.currentTime); } catch (e) {}
                }
                backgroundMusicSource = null;
            }

            const playSequence = (time) => {
                if (gameState !== 'PLAYING' || isMuted) {
                    backgroundMusicSource = null;
                    return;
                }

                let currentTime = time;

                backgroundMusicSource = audioContext.createOscillator();
                backgroundMusicSource.type = 'square';

                const musicGain = audioContext.createGain();
                musicGain.gain.setValueAtTime(0.4, audioContext.currentTime);

                backgroundMusicSource.connect(musicGain);
                musicGain.connect(masterGain);

                melody.forEach(note => {
                    const duration = note.duration * tempo;

                    if (note.freq > 0) {
                        backgroundMusicSource.frequency.setValueAtTime(note.freq, currentTime);
                        musicGain.gain.setValueAtTime(0.4, currentTime);
                        musicGain.gain.exponentialRampToValueAtTime(0.0001, currentTime + duration * 0.95);
                    } else {
                        musicGain.gain.setValueAtTime(0.0001, currentTime);
                    }

                    currentTime += duration;
                });

                backgroundMusicSource.start(time);
                backgroundMusicSource.stop(currentTime);

                backgroundMusicSource.onended = () => {
                    if (gameState === 'PLAYING' && !isMuted) {
                        playSequence(audioContext.currentTime);
                    } else {
                        backgroundMusicSource = null;
                    }
                };
            };

            playSequence(audioContext.currentTime);
        }

        function playSound(frequency, duration, type, endFrequency = frequency, volume = 0.5) {
            if (isMuted) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            if (endFrequency !== frequency) {
                oscillator.frequency.linearRampToValueAtTime(endFrequency, audioContext.currentTime + duration);
            }

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(masterGain);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playExplosion(pitch) {
            playSound(pitch, 0.1, 'triangle', pitch * 0.5, 0.6);
        }
        
        function playBombaSound() {
            playSound(150, 0.3, 'sawtooth', 50, 0.8);
        }
        
        function playPowerUpSound() {
            playSound(300, 0.2, 'square', 700, 0.7);
        }

        function playHealSound() {
            playSound(400, 0.15, 'sine', 800, 0.8);
        }

        function toggleAudio() {
            isMuted = !isMuted;
            if (isMuted) {
                masterGain.gain.setValueAtTime(0, audioContext.currentTime);
                audioToggle.textContent = 'üîá';

                if (backgroundMusicSource) {
                    try { backgroundMusicSource.stop(audioContext.currentTime); } catch (e) {}
                    backgroundMusicSource = null;
                }

            } else {
                masterGain.gain.setValueAtTime(1, audioContext.currentTime);
                audioToggle.textContent = 'üîä';

                if (gameState === 'PLAYING' && !backgroundMusicSource) {
                    startBackgroundMusic();
                }
            }
        }

        audioToggle.addEventListener('click', toggleAudio);

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Tab' && gameState === 'PLAYING') {
                e.preventDefault();
                toggleAudio();
            }
        });

        // --- CLASE EXPLOSI√ìN (Se mantiene) ---
        class Explosion {
            constructor(x, y, color) {
                this.particles = [];
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        size: Math.random() * 4 + 2,
                        color: color,
                        vx: Math.random() * 6 - 3,
                        vy: Math.random() * 6 - 3,
                        life: 30
                    });
                }
            }
            update() {
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                });
                this.particles = this.particles.filter(p => p.life > 0);
                return this.particles.length > 0;
            }
            draw() {
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                });
            }
        }
        
        // NUEVO: Clase para explosi√≥n grande de la bomba
        class BigExplosion {
            constructor(x, y, color) {
                this.particles = [];
                for (let i = 0; i < 30; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        size: Math.random() * 6 + 3,
                        color: color,
                        vx: Math.random() * 10 - 5,
                        vy: Math.random() * 10 - 5,
                        life: 45
                    });
                }
            }
            update() {
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                });
                this.particles = this.particles.filter(p => p.life > 0);
                return this.particles.length > 0;
            }
            draw() {
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                });
            }
        }

        // --- CLASE PARA TEXTOS FLOTANTES (Se mantiene) ---
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.vy = -1.5;
                this.life = 60;
                this.maxLife = 60;
            }
            update() {
                this.y += this.vy;
                this.life--;
                return this.life > 0;
            }
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;

                ctx.fillStyle = this.color;
                ctx.font = '24px monospace';
                ctx.textAlign = 'center';

                ctx.shadowColor = 'black';
                ctx.shadowBlur = 3;

                ctx.fillText(this.text, this.x, this.y);

                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }

        // --- 3. RESPONSIVE DESIGN Y MANEJO DE VENTANA ---

        function resizeGame() {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const aspectR = BASE_W / BASE_H;

            let newW, newH;

            const maxContainerW = viewportW * 0.98;
            const maxContainerH = viewportH * 0.98;

            if (maxContainerW / maxContainerH > aspectR) {
                newH = maxContainerH;
                newW = maxContainerH * aspectR;
            } else {
                newW = maxContainerW;
                newH = maxContainerW / aspectR;
            }

            gameContainer.style.width = newW + 'px';
            gameContainer.style.height = newH + 'px';

            W = BASE_W;
            H = BASE_H;
            canvas.width = W;
            canvas.height = H;
        }

        window.addEventListener('resize', resizeGame);
        resizeGame();


        // --- 4. MANEJO DE EVENTOS (T√≠tulo y Controles) ---

        function handleStartGame() {
            if (gameState === 'TITLE') {
                audioContext.resume();
                playSound(440, 0.01, 'sine', 440, 0);

                gameState = 'PLAYING';

                // OCULTAR ELEMENTOS HTML DE LA PORTADA (usan fixed/absolute)
                titleElementsContainer.style.display = 'none';
                mainTitle.style.display = 'none';

                // CLAVE: Pausar la animaci√≥n del fondo
                backgroundPattern.classList.add('paused');

                resetGame();

                startBackgroundMusic();

                if (isMobile) {
                    controls.style.display = 'block';
                    shootButton.style.display = 'flex';
                }
                audioToggle.style.display = 'block';
            }
        }

        // L√≥gica de inicio ahora ligada al bot√≥n
        startButton.addEventListener('click', handleStartGame);
        startButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleStartGame();
        });


        // --- Llenar las instrucciones de la portada ---
        function fillInstructions() {
            const instructionsContent = isMobile ?
                `<h3>CONTROLES M√ìVIL</h3>
                <p><strong>Joystick:</strong> Mover a Santa</p>
                <p><strong>FUEGO:</strong> Disparar</p>
                <p><strong>BOMBA:</strong> ¬°Colecciona cada 500 pts!</p>
                <p><strong>Meta:</strong> ¬°Defiende el √Årbol!</p>` :
                `<h3>CONTROLES PC</h3>
                <p><strong>WASD / Flechas:</strong> Mover</p>
                <p><strong>Espacio / Click Izq:</strong> Disparar</p>
                <p><strong>TAB:</strong> Silenciar Audio</p>
                <p><strong>BOMBA:</strong> ¬°Colecciona cada 500 pts!</p>
                <p><strong>Meta:</strong> ¬°Defiende el √Årbol!</p>`;

            instructionsDiv.innerHTML = instructionsContent;
        }
        fillInstructions();


        // --- Controles de juego (Joystick y Teclado) ---
        let keys = {};
        if (!isMobile) {
            window.addEventListener('keydown', (e) => {
                if (gameState === 'PLAYING') {
                    keys[e.code] = true;
                }
            });
            window.addEventListener('keyup', (e) => {
                if (gameState === 'PLAYING') {
                    keys[e.code] = false;
                    if (e.code === 'Space') santa.shooting = false;
                }
            });
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = true;
            });
            window.addEventListener('mouseup', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = false;
            });
        }

        let joystickActive = false;
        let startX, startY;

        if (isMobile) {
            joystickContainer.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            });
            joystickContainer.addEventListener('touchmove', (e) => {
                if (!joystickActive || gameState !== 'PLAYING') return;
                const touch = e.touches[0];
                const rect = joystickContainer.getBoundingClientRect();
                const deltaX = (touch.clientX - rect.left - rect.width / 2);
                const deltaY = (touch.clientY - rect.top - rect.height / 2);

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                let finalX = deltaX;
                let finalY = deltaY;

                if (distance > JOYSTICK_RADIUS) {
                    finalX = (deltaX / distance) * JOYSTICK_RADIUS;
                    finalY = (deltaY / distance) * JOYSTICK_RADIUS;
                }

                joystickHandle.style.transform = `translate(${finalX}px, ${finalY}px)`;
                santa.dirX = finalX / JOYSTICK_RADIUS;
                santa.dirY = finalY / JOYSTICK_RADIUS;
            });
            const resetJoystick = () => {
                joystickActive = false;
                santa.dirX = 0;
                santa.dirY = 0;
                joystickHandle.style.transform = `translate(0px, 0px)`;
            };
            joystickContainer.addEventListener('touchend', resetJoystick);
            joystickContainer.addEventListener('touchcancel', resetJoystick);

            shootButton.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = true;
            });
            shootButton.addEventListener('touchend', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = false;
            });
        }


        // --- 5. L√ìGICA DEL JUEGO (UPDATE - Se mantiene) ---

        function handleShooting(deltaTime) {
            const currentFireRate = (santa.invincibleTimer > 0) ? 50 : santa.fireRate;

            if ((!isMobile && (keys['Space'] || santa.shooting)) || (isMobile && santa.shooting) || (santa.invincibleTimer > 0)) {
                const currentTime = Date.now();
                if (currentTime - santa.lastShotTime > currentFireRate) {
                    // C√ÅLCULO DE LA DIRECCI√ìN HACIA EL CENTRO DEL √ÅRBOL
                    const dx = tree.x - santa.x;
                    const dy = tree.y - santa.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const nx = dx / dist; // Componente X de direcci√≥n normalizada
                    const ny = dy / dist; // Componente Y de direcci√≥n normalizada

                    bullets.push({
                        x: santa.x,
                        y: santa.y,
                        size: (santa.invincibleTimer > 0) ? 12 : 8,
                        color: (santa.invincibleTimer > 0) ? '#00FFFF' : 'yellow',
                        dirX: nx,
                        dirY: ny
                    });
                    santa.lastShotTime = currentTime;
                    playSound(700, 0.05, 'square');
                }
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.dirX * BULLET_SPEED;
                bullet.y += bullet.dirY * BULLET_SPEED;

                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        explosions.push(new Explosion(enemy.x, enemy.y, enemy.color));

                        floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+10', '#00FFFF'));

                        enemies.splice(j, 1);
                        bullets.splice(i, 1);
                        score += 10;
                        enemiesDefeatedSincePowerUp++;
                        playExplosion(300);

                        hit = true;
                        break;
                    }
                }

                if (!hit && (bullet.x < 0 || bullet.x > W || bullet.y < 0 || bullet.y > H)) {
                    bullets.splice(i, 1);
                }
            }
        }

        function updatePowerUp(deltaTime) {
            if (santa.invincibleTimer > 0) {
                santa.invincibleTimer -= (deltaTime / (1000 / 60));
                if (santa.invincibleTimer <= 0) {
                    santa.invincible = false;
                    santa.invincibleTimer = 0;
                    dialogue.message = "¬°Se agot√≥ la invencibilidad!";
                    dialogue.duration = PHRASE_DURATION;
                    dialogue.powerUpMessage = null;
                }
            }

            if (enemiesDefeatedSincePowerUp >= ENEMIES_FOR_POWERUP) {
                santa.health = santa.maxHealth;
                santa.invincible = true;
                santa.invincibleTimer = POWERUP_DURATION;
                enemiesDefeatedSincePowerUp = 0;
                dialogue.powerUpMessage = invincibilityPhrases[Math.floor(Math.random() * invincibilityPhrases.length)];
                dialogue.message = dialogue.powerUpMessage;
                dialogue.duration = INVINCIBILITY_PHRASE_DURATION;
                playSound(300, 0.2, 'sawtooth', 700);
            }
        }

        function checkHealHit() {
            if (score >= lastHealScore + HEAL_SCORE_HIT) {
                lastHealScore += HEAL_SCORE_HIT;

                const healAmount = tree.maxHealth * 0.5;
                const oldHealth = tree.health;
                const newHealth = Math.min(tree.maxHealth, tree.health + healAmount);

                if (newHealth > oldHealth) {
                    tree.health = newHealth;
                    dialogue.message = `¬°HITO! El √°rbol se ha regenerado un 50%. HP: ${tree.health}`;
                    dialogue.duration = PHRASE_DURATION;
                    tree.healingGlowTimer = GLOW_DURATION;
                    playHealSound();
                }
            }
        }
        
        // NUEVO: Verificar si aparece la bomba
        function checkBombaSpawn() {
            if (score >= lastBombaScore + BOMBA_SCORE_HIT && !bomba.active) {
                lastBombaScore += BOMBA_SCORE_HIT;
                
                // Posici√≥n aleatoria dentro de la arena (evitando bordes)
                bomba.x = Math.random() * (W - 100) + 50;
                bomba.y = Math.random() * (H - 100) + 50;
                bomba.active = true;
                bomba.timer = BOMBA_DURATION;
                bomba.frame = 0;
                
                dialogue.message = "¬°UN ELFO CON BOMBA HA APARECIDO! ¬°COLISIONA CON √âL!";
                dialogue.duration = PHRASE_DURATION;
                playPowerUpSound();
            }
        }
        
        // NUEVO: Actualizar la bomba
        function updateBomba(deltaTime) {
            if (bomba.active) {
                bomba.timer--;
                bomba.frame = (bomba.frame + 0.1) % 4; // Animaci√≥n del elfo
                
                if (bomba.timer <= 0) {
                    bomba.active = false;
                    dialogue.message = "¬°La bomba ha desaparecido! Espera otros 500 pts.";
                    dialogue.duration = PHRASE_DURATION;
                }
                
                // Verificar colisi√≥n con Santa
                if (checkCollision(santa, {x: bomba.x, y: bomba.y, size: BOMBA_SIZE})) {
                    activateBomba();
                }
            }
        }
        
        // NUEVO: Activar el efecto de la bomba
        function activateBomba() {
            let enemiesDestroyed = 0;
            
            // Destruir todos los enemigos en pantalla
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Crear explosi√≥n para cada enemigo
                explosions.push(new BigExplosion(enemy.x, enemy.y, '#FF0000'));
                
                // Texto flotante
                floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+50', '#FFFF00'));
                
                // Sumar puntos y power-up
                score += 50;
                enemiesDefeatedSincePowerUp++;
                enemiesDestroyed++;
                
                // Sonido de explosi√≥n
                playExplosion(200 + i * 20);
            }
            
            // Limpiar todos los enemigos
            enemies = [];
            
            // Efecto visual grande en la posici√≥n de la bomba
            explosions.push(new BigExplosion(bomba.x, bomba.y, '#FF9900'));
            
            // Mensaje de di√°logo
            dialogue.message = `¬°BOOM! ${enemiesDestroyed} enemigos destruidos. +${enemiesDestroyed * 50} pts!`;
            dialogue.duration = PHRASE_DURATION;
            
            // Sonido especial de bomba
            playBombaSound();
            
            // Desactivar la bomba
            bomba.active = false;
            
            // Verificar si se activa el power-up de invencibilidad
            if (enemiesDefeatedSincePowerUp >= ENEMIES_FOR_POWERUP) {
                santa.health = santa.maxHealth;
                santa.invincible = true;
                santa.invincibleTimer = POWERUP_DURATION;
                enemiesDefeatedSincePowerUp = 0;
                dialogue.powerUpMessage = "¬°BOMBA PLUS! ¬°Invencibilidad activada!";
                dialogue.message = dialogue.powerUpMessage;
                dialogue.duration = INVINCIBILITY_PHRASE_DURATION;
                playSound(300, 0.2, 'sawtooth', 700);
            }
        }

        function updatePlayerMovement() {
            const originalY = BASE_H / 2 + santa.y - (BASE_H / 2);

            if (!isMobile) {
                santa.dirX = 0;
                santa.dirY = 0;
                if (keys['KeyA'] || keys['ArrowLeft']) santa.dirX = -1;
                if (keys['KeyD'] || keys['ArrowRight']) santa.dirX = 1;
                if (keys['KeyW'] || keys['ArrowUp']) santa.dirY = -1;
                if (keys['KeyS'] || keys['ArrowDown']) santa.dirY = 1;
            }

            const magnitude = Math.sqrt(santa.dirX * santa.dirX + santa.dirY * santa.dirY);

            if (santa.hitTimer > 0) {
                santa.y -= 3 * (santa.hitTimer / HIT_DURATION);
                santa.hitTimer--;
            }

            if (magnitude === 0 && santa.hitTimer === 0) {
                santa.y += Math.sin(gameFrame * 0.05) * 0.2;
                santa.frame = 0;
            } else if (santa.hitTimer === 0) {
                const nx = santa.dirX / magnitude;
                const ny = santa.dirY / magnitude;
                const speed = (santa.invincibleTimer > 0) ? PLAYER_SPEED * 1.5 : PLAYER_SPEED;

                santa.x += nx * speed;
                santa.y += ny * speed;
                santa.frame = (santa.frame + 0.1) % 2;
            }

            santa.x = Math.max(santa.size / 2, Math.min(W - santa.size / 2, santa.x));
            santa.y = Math.max(santa.size / 2, Math.min(H - santa.size / 2, santa.y));
        }
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) {
                    explosions.splice(i, 1);
                }
            }
        }

        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                if (!floatingTexts[i].update()) {
                    floatingTexts.splice(i, 1);
                }
            }
        }

        function spawnEnemies() {
            if (Math.random() < spawnRate) {

                let totalWeight = ENEMY_TYPES.reduce((sum, type) => sum + type.spawnWeight, 0);
                let randomValue = Math.random() * totalWeight;
                let selectedType = ENEMY_TYPES[0];

                for (const type of ENEMY_TYPES) {
                    randomValue -= type.spawnWeight;
                    if (randomValue <= 0) {
                        selectedType = type;
                        break;
                    }
                }

                const size = ENEMY_BASE_SIZE;
                const edge = Math.floor(Math.random() * 4);
                let x, y;
                switch (edge) {
                    case 0: x = Math.random() * W; y = -size; break;
                    case 1: x = W + size; y = Math.random() * H; break;
                    case 2: x = Math.random() * W; y = H + size; break;
                    case 3: x = -size; y = Math.random() * H; break;
                }

                enemies.push({
                    x: x,
                    y: y,
                    size: size,
                    color: selectedType.color,
                    speed: selectedType.speed,
                    walkFrame: 0
                });
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = tree.x - enemy.x;
                const dy = tree.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / dist;
                const ny = dy / dist;

                enemy.x += nx * enemy.speed;
                enemy.y += ny * enemy.speed;

                enemy.walkFrame = (enemy.walkFrame + 0.1 * enemy.speed) % 3;

                let destroyed = false;

                if (checkCollision(enemy, santa)) {
                    if (!santa.invincible) {
                        santa.health -= 1;
                        santa.hitTimer = HIT_DURATION;
                        explosions.push(new Explosion(enemy.x, enemy.y, 'white'));
                        playSound(150, 0.1, 'square', 100);

                        if (santa.health <= 0) {
                            alert('GAME OVER! Santa ha sido sobrepasado. Puntuaci√≥n: ' + score);
                            playSound(200, 1.0, 'sine', 50);
                            gameState = 'TITLE';
                            resetGame();

                            // MOSTRAR ELEMENTOS HTML DE LA PORTADA
                            titleElementsContainer.style.display = 'flex';
                            mainTitle.style.display = 'block';

                            // CLAVE: Reanudar la animaci√≥n del fondo
                            backgroundPattern.classList.remove('paused');

                            if (isMobile) {
                                controls.style.display = 'none';
                                shootButton.style.display = 'none';
                            }
                            audioToggle.style.display = 'none';
                            return;
                        }
                    } else {
                        explosions.push(new Explosion(enemy.x, enemy.y, '#FF00FF'));
                    }

                    enemies.splice(i, 1);
                    destroyed = true;
                }

                if (!destroyed && checkCollision(enemy, tree)) {
                    tree.health -= 1;

                    // CLAVE: Activar el temporizador de glitch
                    tree.damageGlitchTimer = GLITCH_DURATION;

                    enemies.splice(i, 1);

                    floatingTexts.push(new FloatingText(tree.x, tree.y - tree.size * 0.8, '-1', '#FF0000'));

                    explosions.push(new Explosion(enemy.x, enemy.y, '#990000'));

                    if (tree.health <= 0) {
                        alert('GAME OVER! El √°rbol ha sido talado. Puntuaci√≥n: ' + score);
                        playSound(200, 1.0, 'sine', 50);
                        gameState = 'TITLE';
                        resetGame();

                        // MOSTRAR ELEMENTOS HTML DE LA PORTADA
                            titleElementsContainer.style.display = 'flex';
                            mainTitle.style.display = 'block';

                            // CLAVE: Reanudar la animaci√≥n del fondo
                            backgroundPattern.classList.remove('paused');

                            if (isMobile) {
                                controls.style.display = 'none';
                                shootButton.style.display = 'none';
                            }
                            audioToggle.style.display = 'none';
                            return;
                    }
                }
            }
        }

        function updateDialogue(deltaTime) {
            if (dialogue.duration > 0) {
                dialogue.duration -= (deltaTime / (1000 / 60));
            }

            if (santa.invincibleTimer > 0 && dialogue.powerUpMessage && dialogue.duration <= 0) {
                if (Math.random() < INVINCIBILITY_PHRASE_CHANCE) {
                    dialogue.message = dialogue.powerUpMessage;
                    dialogue.duration = INVINCIBILITY_PHRASE_DURATION;
                }
                return;
            }

            timeSinceLastPhrase += deltaTime;
            if (timeSinceLastPhrase > PHRASE_INTERVAL && dialogue.duration <= 0 && santa.invincibleTimer <= 0) {
                let eligiblePhrases = [];
                for(const group of sarcasticPhrases) {
                    if (tree.health >= group.min) {
                        eligiblePhrases = group.phrases;
                        break;
                    }
                }
                if (eligiblePhrases.length > 0) {
                    const newPhrase = eligiblePhrases[Math.floor(Math.random() * eligiblePhrases.length)];
                    dialogue.message = newPhrase;
                    dialogue.duration = PHRASE_DURATION;
                    timeSinceLastPhrase = 0;
                }
            }
        }
        function checkCollision(objA, objB) {
            const sizeA = objA.size || 0;
            const sizeB = objB.size || 0;

            const overlap = 0.8;

            return objA.x < objB.x + sizeB * overlap &&
                objA.x + sizeA * overlap > objB.x &&
                objA.y < objB.y + sizeB * overlap &&
                objA.y + sizeA * overlap > objB.y;
        }


        function updateGame(deltaTime) {
            updatePlayerMovement();
            updatePowerUp(deltaTime);
            handleShooting(deltaTime);
            updateBullets();
            updateExplosions();
            updateFloatingTexts();
            spawnEnemies();
            updateEnemies();
            updateDialogue(deltaTime);
            checkHealHit();
            checkBombaSpawn(); // NUEVO: Verificar si aparece la bomba
            updateBomba(deltaTime); // NUEVO: Actualizar la bomba

            gameFrame++;
            if (tree.healingGlowTimer > 0) {
                tree.healingGlowTimer--;
            }
            if (tree.damageGlitchTimer > 0) {
                tree.damageGlitchTimer--;
            }
        }

        // --- 6. RENDERIZADO (DRAW) ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x - w / 2, y - h / 2, w, h);
        }
        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawShadow(x, y, width, height, opacity = 0.35) {
            ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
            ctx.beginPath();
            ctx.ellipse(x, y, width / 2, height * 0.4 / 2, 0, 0, Math.PI * 2);
            ctx.fill();
        }


        function drawSanta(x, y, size, frame) {
            if (santa.invincible && Math.floor(santa.invincibleTimer / 5) % 2 === 0) {
                return;
            }

            const s = size;
            const halfS = s / 2;
            const p = s / 20;

            drawShadow(x, y + halfS + p * 6, s * 1.4, s * 0.8);

            let legOffset = 0;
            if (santa.dirX !== 0 || santa.dirY !== 0) {
                legOffset = (Math.floor(frame) === 0) ? s * 0.15 : -s * 0.15;
            }

            let bodyOffset = 0;
            if (santa.hitTimer > 0) {
                bodyOffset = -s * 0.1;
            }

            const headYOffset = -s * 0.2;
            const bodyYOffset = -s * 0.1;

            drawRect(x, y - halfS + p * 2 + headYOffset, s * 0.9, s * 0.4, 'red');
            drawCircle(x + s * 0.35, y - halfS + p + headYOffset, s * 0.15, 'white');
            drawRect(x, y - halfS + p * 5 + headYOffset, s, p * 2, 'white');

            drawRect(x, y - s * 0.1 + headYOffset, s * 0.4, s * 0.2, '#FFDBAC');
            drawRect(x - s * 0.1, y - s * 0.2 + headYOffset, p, p, 'black');
            drawRect(x + s * 0.1, y - s * 0.2 + headYOffset, p, p, 'black');

            drawRect(x, y + s * 0.2 + headYOffset, s * 1.2, s * 0.4, 'white');

            drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.8, s * 0.35, 'red');
            drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.8, s * 0.1, 'black');
            drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.2, s * 0.15, '#FFD700');

            drawRect(x - s * 0.2 + legOffset, y + s * 0.85 + bodyYOffset, s * 0.15, s * 0.2, 'black');
            drawRect(x + s * 0.2 + legOffset, y + s * 0.85 + bodyYOffset, s * 0.15, s * 0.2, 'black');
        }
        
        // NUEVO: Dibujar el elfo con bomba
        function drawBomba() {
            if (!bomba.active) return;
            
            const x = bomba.x;
            const y = bomba.y;
            const s = BOMBA_SIZE;
            const halfS = s / 2;
            const p = s / 20;
            
            // Sombra
            drawShadow(x, y + halfS + 4, s * 1.2, s * 0.8);
            
            // Animaci√≥n de parpadeo cuando est√° por desaparecer
            if (bomba.timer < 60) {
                if (Math.floor(bomba.timer / 5) % 2 === 0) return;
            }
            
            // Cuerpo del elfo (verde)
            drawRect(x, y - halfS + p * 2, s * 0.9, s * 0.4, '#00AA00');
            
            // Sombrero puntiagudo (rojo con blanco)
            drawRect(x, y - halfS - p * 2, s * 0.6, s * 0.3, '#FF0000');
            drawRect(x, y - halfS - p * 4, s * 0.3, s * 0.3, '#FF0000');
            drawRect(x, y - halfS - p, s * 0.7, p * 2, '#FFFFFF');
            
            // Cara
            drawRect(x, y - s * 0.1, s * 0.4, s * 0.2, '#FFDBAC');
            drawRect(x - s * 0.1, y - s * 0.2, p, p, 'black');
            drawRect(x + s * 0.1, y - s * 0.2, p, p, 'black');
            drawRect(x, y, s * 0.3, p, '#FF0000');
            
            // Cuerpo y ropa
            drawRect(x, y + s * 0.2, s * 1.0, s * 0.4, '#00AA00');
            drawRect(x, y + s * 0.4, s * 0.8, s * 0.2, '#8B4513');
            
            // Brazos
            const armFrame = Math.floor(bomba.frame);
            let armOffset = 0;
            if (armFrame === 0 || armFrame === 2) {
                armOffset = s * 0.15;
            } else {
                armOffset = -s * 0.15;
            }
            
            drawRect(x - s * 0.4 + armOffset, y + s * 0.1, s * 0.2, s * 0.3, '#00AA00');
            drawRect(x + s * 0.4 - armOffset, y + s * 0.1, s * 0.2, s * 0.3, '#00AA00');
            
            // La BOMBA (en las manos)
            const bombSize = s * 0.3;
            const bombColor = bomba.timer < 100 ? '#FF0000' : '#FF9900';
            
            // Bomba en mano izquierda
            drawCircle(x - s * 0.4 + armOffset, y + s * 0.25, bombSize, bombColor);
            drawRect(x - s * 0.4 + armOffset, y + s * 0.25 - bombSize/3, bombSize/2, bombSize/4, '#666666');
            
            // Bomba en mano derecha
            drawCircle(x + s * 0.4 - armOffset, y + s * 0.25, bombSize, bombColor);
            drawRect(x + s * 0.4 - armOffset, y + s * 0.25 - bombSize/3, bombSize/2, bombSize/4, '#666666');
            
            // Mecha parpadeante
            if (Math.floor(gameFrame / 10) % 2 === 0) {
                drawRect(x - s * 0.4 + armOffset, y + s * 0.25 - bombSize, bombSize/3, bombSize/2, '#FFFF00');
                drawRect(x + s * 0.4 - armOffset, y + s * 0.25 - bombSize, bombSize/3, bombSize/2, '#FFFF00');
            }
            
            // Piernas
            drawRect(x - s * 0.15, y + s * 0.6, s * 0.2, s * 0.3, '#8B4513');
            drawRect(x + s * 0.15, y + s * 0.6, s * 0.2, s * 0.3, '#8B4513');
            
            // Indicador visual del tiempo restante
            if (bomba.timer < 120) {
                const timeAlpha = bomba.timer / 120;
                ctx.fillStyle = `rgba(255, 0, 0, ${0.5 + 0.5 * Math.sin(gameFrame * 0.2)})`;
                ctx.beginPath();
                ctx.arc(x, y - s * 1.5, s * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(Math.ceil(bomba.timer / 60), x, y - s * 1.5 + 3);
            }
        }

        // NUEVO: Dibuja los personajes y el √°rbol para la portada (POSICI√ìN A ESCALA)
        function drawTitleCharacters() {
            // Asegura que el canvas siempre se limpie en sus dimensiones actuales
            ctx.clearRect(0, 0, W, H);

            // Tama√±os y offsets que son proporcionales a las dimensiones del canvas (W, H)
            const MIN_DIM = Math.min(W, H);
            const TREE_SIZE = MIN_DIM * 0.12;
            const CHARACTER_SIZE = MIN_DIM * 0.08;
            const OFFSET = W * 0.25;

            // CLAVE: CENTRAMOS EN EL CENTRO DEL CANVAS
            const CENTER_X = W / 2;
            const CENTER_Y = H / 2;

            // 1. √Årbol (Centro)
            tree.x = CENTER_X;
            tree.y = CENTER_Y;
            tree.size = TREE_SIZE;
            drawTree();
            tree.size = 40;

            // 2. Santa (Derecha)
            const santaX = CENTER_X + OFFSET;
            const santaY = CENTER_Y + CHARACTER_SIZE * 0.2; // Peque√±o ajuste visual para la base
            drawSanta(santaX, santaY, CHARACTER_SIZE, gameFrame / 5);

            // 3. Enemigo (Izquierda)
            const enemyX = CENTER_X - OFFSET;
            const enemyY = CENTER_Y + CHARACTER_SIZE * 0.2;

            const e = {
                x: enemyX,
                y: enemyY,
                size: CHARACTER_SIZE,
                color: ENEMY_TYPES[0].color,
                walkFrame: gameFrame / 15
            };

            const s = e.size;
            const color = e.color;
            const halfS = s / 2;

            drawShadow(e.x, e.y + halfS + 4, s * 1.2, s * 0.8);

            const walkFrame = Math.floor(e.walkFrame % 3);
            let legOffsetL = 0;
            let legOffsetR = 0;
            let bodyTilt = 0;

            if (walkFrame === 0) {
                legOffsetL = s * 0.15;
                legOffsetR = -s * 0.15;
                bodyTilt = -s * 0.05;
            } else if (walkFrame === 1) {
                legOffsetL = 0;
                legOffsetR = 0;
                bodyTilt = 0;
            } else if (walkFrame === 2) {
                legOffsetL = -s * 0.15;
                legOffsetR = s * 0.15;
                bodyTilt = s * 0.05;
            }

            let suitColor = color;
            if (color === '#666666') suitColor = '#444444';

            const headY = e.y - halfS + bodyTilt;
            const hairColor = '#333333';
            const skinColor = '#39ff14';
            const beardColor = '#39ff14';

            drawRect(e.x, headY + s * 0.0, s * 0.8, s * 0.2, hairColor);
            drawRect(e.x, headY + s * 0.25, s * 0.6, s * 0.2, skinColor);
            drawRect(e.x, headY + s * 0.25, s * 0.7, s * 0.2, 'black');
            drawRect(e.x, headY + s * 0.5, s * 0.8, s * 0.25, beardColor);

            const bodyY = e.y + s * 0.45 + bodyTilt * 0.5;
            drawRect(e.x, bodyY, s * 0.8, s * 0.4, suitColor);

            drawRect(e.x, e.y + s * 0.25, s * 0.2, s * 0.1, 'white');
            drawRect(e.x, e.y + s * 0.35, s * 0.1, s * 0.2, color);

            const legY = e.y + s * 0.7;
            drawRect(e.x - s * 0.15 + legOffsetL, legY, s * 0.2, s * 0.3, '#333333');
            drawRect(e.x + s * 0.15 + legOffsetR, legY, s * 0.2, s * 0.3, '#333333');
        }

        // NUEVO: Dibuja la pantalla de t√≠tulo en el canvas
        function drawTitleScreen() {
            drawTitleCharacters();
        }


        function drawGameObjects() {
            ctx.clearRect(0, 0, W, H);

            // --- INICIO DE EFECTOS DEL √ÅRBOL (Glitch) ---
            if (tree.damageGlitchTimer > 0) {
                // 1. Temblor (Transformaci√≥n)
                const shakeX = Math.random() * 4 - 2; // Desplazamiento de -2 a 2
                const shakeY = Math.random() * 4 - 2;
                ctx.setTransform(1, 0, 0, 1, shakeX, shakeY);

                // 2. Glitch de Color (Filtro)
                const hue = Math.floor(Math.random() * 360);
                ctx.filter = `hue-rotate(${hue}deg) brightness(1.5)`;
            } else {
                ctx.filter = 'none';
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
            // --- FIN DE EFECTOS DEL √ÅRBOL ---

            ctx.globalAlpha = 1;

            drawTree();

            // Revertir la transformaci√≥n y el filtro antes de dibujar otros elementos (enemigos/Santa/HUD)
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.filter = 'none';

            drawEnemies();
            drawBullets();
            drawSanta(santa.x, santa.y, santa.size, santa.frame);
            drawBomba(); // NUEVO: Dibujar la bomba si est√° activa
            explosions.forEach(exp => exp.draw());

            floatingTexts.forEach(t => t.draw());

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.filter = 'none';
            ctx.globalAlpha = 1;

            // --- CORRECCI√ìN: Dibujar el di√°logo si est√° activo ---
            if (dialogue.duration > 0) {
                drawDialogueBubble(santa.x, santa.y, dialogue.message);
            }

            drawHUD();
        }

        function drawTree() {
            const treeBaseW = tree.size * 2;
            const baseCenterY = tree.y + tree.size / 2;

            drawShadow(tree.x, baseCenterY + 15, treeBaseW * 1.4, treeBaseW * 0.8);

            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';


            const SECTION_HEIGHT_FACTOR = 0.7;
            const SECTION_GAP_FACTOR = 0.4;

            const baseH = treeBaseW * SECTION_HEIGHT_FACTOR;
            const h1 = baseH * 1.0;
            const h2 = baseH * 0.8;
            const h3 = baseH * 0.6;

            const totalTreeHeight = h1 + h2 * SECTION_GAP_FACTOR + h3 * SECTION_GAP_FACTOR + tree.size * 0.25;
            const treeTopY = tree.y - totalTreeHeight / 2;

            const Y_TOP_BASE = treeTopY;

            const SECTIONS_CONFIG = [
                { factor: 0.6, height: h3, yCenter: Y_TOP_BASE + h3 / 2 },
                { factor: 0.8, height: h2, yCenter: Y_TOP_BASE + h3 + h2 / 2 - (h2 * SECTION_GAP_FACTOR) },
                { factor: 1.0, height: h1, yCenter: Y_TOP_BASE + h3 + h2 - (h2 * SECTION_GAP_FACTOR * 2) + h1 * 0.1 }
            ];

            const ORNAMENTS = [
                { x: -10, y: SECTIONS_CONFIG[2].yCenter + 15, color: 'yellow' }, { x: 15, y: SECTIONS_CONFIG[2].yCenter + 30, color: 'red' },
                { x: -8, y: SECTIONS_CONFIG[1].yCenter + 0, color: 'blue' }, { x: 10, y: SECTIONS_CONFIG[1].yCenter - 10, color: 'magenta' },
                { x: -5, y: SECTIONS_CONFIG[0].yCenter - 5, color: 'cyan' }, { x: 5, y: SECTIONS_CONFIG[0].yCenter - 15, color: 'yellow' }
            ];

            const trunkY = SECTIONS_CONFIG[2].yCenter + h1 / 2 + tree.size * 0.1;
            drawRect(tree.x, trunkY, tree.size * 0.2, tree.size * 0.3, '#8B4513');

            SECTIONS_CONFIG.forEach((sec) => {
                const w = treeBaseW * sec.factor;
                const h = sec.height;
                const topY = sec.yCenter - h / 2;
                const bottomY = sec.yCenter + h / 2;

                ctx.fillStyle = tree.color;

                ctx.beginPath();
                ctx.moveTo(tree.x, topY);
                ctx.lineTo(tree.x - w * 0.5, bottomY);
                ctx.lineTo(tree.x + w * 0.5, bottomY);
                ctx.closePath();
                ctx.fill();
            });

            const pulse = Math.floor(gameFrame / 10) % 3;
            const lightColors = ['yellow', 'red', 'blue'];

            ORNAMENTS.forEach((ornament, index) => {
                drawCircle(tree.x + ornament.x, ornament.y, tree.size * 0.075, ornament.color);
            });

            drawCircle(tree.x - tree.size * 0.3, SECTIONS_CONFIG[2].yCenter + 0, tree.size * 0.1, lightColors[(pulse + 0) % 3]);
            drawCircle(tree.x + tree.size * 0.25, SECTIONS_CONFIG[1].yCenter - 20, tree.size * 0.1, lightColors[(pulse + 1) % 3]);
            drawCircle(tree.x + 0, SECTIONS_CONFIG[2].yCenter + tree.size * 0.5, tree.size * 0.1, lightColors[(pulse + 2) % 3]);

            drawRect(tree.x, SECTIONS_CONFIG[0].yCenter - h3 * 0.5 - tree.size * 0.2, tree.size * 0.25, tree.size * 0.25, 'yellow');
        }

        function drawEnemies() {
            enemies.forEach(e => {
                const x = e.x;
                const y = e.y;

                const pulse = 1 + Math.sin(gameFrame * 0.1 * e.speed) * 0.05;
                const s = ENEMY_BASE_SIZE * pulse;
                const color = e.color;
                const halfS = s / 2;

                drawShadow(x, y + halfS + 4, s * 1.2, s * 0.8);

                const walkFrame = Math.floor(e.walkFrame);
                let legOffsetL = 0;
                let legOffsetR = 0;
                let bodyTilt = 0;

                if (walkFrame === 0) {
                    legOffsetL = s * 0.15;
                    legOffsetR = -s * 0.15;
                    bodyTilt = -s * 0.05;
                } else if (walkFrame === 1) {
                    legOffsetL = 0;
                    legOffsetR = 0;
                    bodyTilt = 0;
                } else if (walkFrame === 2) {
                    legOffsetL = -s * 0.15;
                    legOffsetR = s * 0.15;
                    bodyTilt = s * 0.05;
                }

                let suitColor = color;
                if (color === '#666666') suitColor = '#444444';
                else if (color === '#990000') suitColor = '#660000';
                else if (color === '#000066') suitColor = '#000044';

                const headY = y - halfS + bodyTilt;
                const hairColor = '#333333';
                const skinColor = '#39ff14';
                const beardColor = '#39ff14';

                drawRect(x, headY + s * 0.0, s * 0.8, s * 0.2, hairColor);
                drawRect(x, headY + s * 0.25, s * 0.6, s * 0.2, skinColor);
                drawRect(x, headY + s * 0.25, s * 0.7, s * 0.2, 'black');
                drawRect(x, headY + s * 0.5, s * 0.8, s * 0.25, beardColor);

                const bodyY = y + s * 0.45 + bodyTilt * 0.5;
                drawRect(x, bodyY, s * 0.8, s * 0.4, suitColor);

                drawRect(x, y + s * 0.25, s * 0.2, s * 0.1, 'white');
                drawRect(x, y + s * 0.35, s * 0.1, s * 0.2, color);

                const legY = y + s * 0.7;
                drawRect(x - s * 0.15 + legOffsetL, legY, s * 0.2, s * 0.3, '#333333');
                drawRect(x + s * 0.15 + legOffsetR, legY, s * 0.2, s * 0.3, '#333333');
            });
        }

        function drawBullets() {
            bullets.forEach(b => {
                ctx.shadowColor = b.color;
                ctx.shadowBlur = 5;
                drawRect(b.x, b.y, b.size, b.size, b.color);
                ctx.shadowBlur = 0;
            });
        }

        function drawDialogueBubble(x, y, message) {
            const FONT_SIZE = 12; // Reducido de 14 a 12
            const MAX_WIDTH = 280; // Ancho m√°ximo en p√≠xeles (no caracteres)
            const MAX_LINES = 4; // Permitir hasta 4 l√≠neas
            const PADDING = 10;
            const LINE_HEIGHT = FONT_SIZE + 6;
            
            ctx.font = `${FONT_SIZE}px 'Press Start 2P', monospace`;
            ctx.textAlign = 'center';

            // Funci√≥n para dividir el texto en l√≠neas
            function splitTextIntoLines(text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    const testLine = currentLine ? `${currentLine} ${word}` : word;
                    const testWidth = ctx.measureText(testLine).width;
                    
                    if (testWidth <= maxWidth) {
                        currentLine = testLine;
                    } else {
                        // Si la l√≠nea actual no est√° vac√≠a, la guardamos
                        if (currentLine) {
                            lines.push(currentLine);
                        }
                        
                        // Si la palabra sola es m√°s ancha que el m√°ximo, la dividimos
                        if (ctx.measureText(word).width > maxWidth) {
                            // Dividir palabra larga
                            let remainingWord = word;
                            while (remainingWord.length > 0) {
                                let segment = '';
                                for (let j = 0; j < remainingWord.length; j++) {
                                    const testSegment = segment + remainingWord[j];
                                    if (ctx.measureText(testSegment).width <= maxWidth) {
                                        segment = testSegment;
                                    } else {
                                        break;
                                    }
                                }
                                lines.push(segment);
                                remainingWord = remainingWord.slice(segment.length);
                            }
                            currentLine = '';
                        } else {
                            currentLine = word;
                        }
                    }
                }
                
                // A√±adir la √∫ltima l√≠nea si existe
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                return lines;
            }

            // Dividir el mensaje en l√≠neas
            let lines = splitTextIntoLines(message, MAX_WIDTH);
            
            // Limitar el n√∫mero de l√≠neas si es necesario
            if (lines.length > MAX_LINES) {
                lines = lines.slice(0, MAX_LINES);
                lines[MAX_LINES - 1] = lines[MAX_LINES - 1].slice(0, -3) + '...';
            }
            
            // Calcular el ancho m√°ximo de l√≠nea
            let maxLineWidth = 0;
            for (const line of lines) {
                const lineWidth = ctx.measureText(line).width;
                maxLineWidth = Math.max(maxLineWidth, lineWidth);
            }
            
            const bubbleW = Math.min(maxLineWidth + PADDING * 2, MAX_WIDTH + PADDING * 2);
            const bubbleH = (lines.length * LINE_HEIGHT) + PADDING * 2;

            const bubbleX = x - bubbleW / 2;
            const bubbleY = y - santa.size - bubbleH - 15;

            // Fondo blanco con borde negro
            ctx.fillStyle = 'white';
            ctx.fillRect(bubbleX, bubbleY, bubbleW, bubbleH);
            
            // Borde negro grueso
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeRect(bubbleX, bubbleY, bubbleW, bubbleH);

            // Punta del di√°logo (tri√°ngulo en la parte inferior)
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(x - 8, bubbleY + bubbleH);
            ctx.lineTo(x + 8, bubbleY + bubbleH);
            ctx.lineTo(x, bubbleY + bubbleH + 10);
            ctx.closePath();
            ctx.fill();
            
            // Borde de la punta
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - 8, bubbleY + bubbleH);
            ctx.lineTo(x + 8, bubbleY + bubbleH);
            ctx.lineTo(x, bubbleY + bubbleH + 10);
            ctx.closePath();
            ctx.stroke();

            // Texto negro
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            
            // Dibujar cada l√≠nea centrada
            lines.forEach((line, index) => {
                const textY = bubbleY + PADDING + (index * LINE_HEIGHT) + FONT_SIZE;
                ctx.fillText(line, x, textY);
            });
        }


        function drawHUD() {
            // Configuramos un estilo base para el HUD
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            ctx.shadowBlur = 5;
            ctx.lineWidth = 3; // Grosor de los bordes

            ctx.font = '20px "Press Start 2P", monospace'; // Aplicamos la fuente retro al canvas

            // ------------------- Puntuaci√≥n -------------------
            ctx.fillStyle = '#FFD700'; // Color Oro
            ctx.textAlign = 'left';
            ctx.fillText(`PUNTOS: ${score}`, 10, 30);
            
            // ------------------- Indicador de BOMBA (abajo del contador de puntos) -------------------
            const nextBomba = BOMBA_SCORE_HIT - (score - lastBombaScore);
            if (nextBomba > 0) {
                ctx.fillStyle = '#FF9900';
                ctx.textAlign = 'left';
                ctx.fillText(`BOMBA: ${nextBomba}`, 10, 60);
            } else if (bomba.active) {
                ctx.fillStyle = '#FF0000';
                ctx.textAlign = 'left';
                const timeLeft = Math.ceil(bomba.timer / 60);
                ctx.fillText(`¬°BOMBA! ${timeLeft}s`, 10, 60);
            }

            // ------------------- Barra de Vida del √ÅRBOL -------------------
            const treeHealthRatio = tree.health / tree.maxHealth;
            const barWidth = 300;
            const barHeight = 20; // Un poco m√°s alta
            const barX = W / 2 - barWidth / 2;
            const barY = 15;

            // GLOW de curaci√≥n
            if (tree.healingGlowTimer > 0) {
                const glowAlpha = tree.healingGlowTimer / GLOW_DURATION * 0.7;
                ctx.fillStyle = `rgba(0, 255, 0, ${glowAlpha})`;
                ctx.fillRect(barX - 8, barY - 8, barWidth + 16, barHeight + 16);
            }

            // Fondo de la barra
            ctx.fillStyle = '#333333';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Relleno de salud
            ctx.fillStyle = treeHealthRatio > 0.5 ? '#00FF00' : (treeHealthRatio > 0.2 ? '#FFD700' : '#FF0000');
            ctx.fillRect(barX, barY, barWidth * treeHealthRatio, barHeight);

            // Borde Doble
            ctx.strokeStyle = '#000000';
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            ctx.strokeStyle = '#FFFFFF';
            ctx.strokeRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);

            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(`√ÅRBOL`, W / 2, barY + barHeight + 25);


            // ------------------- Barra de Vida de SANTA (regresada a su posici√≥n original) -------------------
            const santaHealthRatio = santa.health / santa.maxHealth;
            const santaBarWidth = 150;
            const santaBarHeight = 15;
            const santaBarX = W - santaBarWidth - 10;
            const santaBarY = 15; // Regresada a su posici√≥n original (arriba)

            // Fondo de la barra
            ctx.fillStyle = '#333333';
            ctx.fillRect(santaBarX, santaBarY, santaBarWidth, santaBarHeight);

            // Relleno de salud
            ctx.fillStyle = santaHealthRatio > 0.5 ? '#00FFFF' : (santaHealthRatio > 0.2 ? '#FFD700' : '#FF0000');
            ctx.fillRect(santaBarX, santaBarY, santaBarWidth * santaHealthRatio, santaBarHeight);

            // Borde Doble
            ctx.strokeStyle = '#000000';
            ctx.strokeRect(santaBarX, santaBarY, santaBarWidth, santaBarHeight);
            ctx.strokeStyle = '#FFFFFF';
            ctx.strokeRect(santaBarX - 1, santaBarY - 1, santaBarWidth + 2, santaBarHeight + 2);

            ctx.fillStyle = 'white';
            ctx.textAlign = 'right';
            ctx.fillText(`SANTA`, W - 10, santaBarY + santaBarHeight + 5);

            // ------------------- Barra de POWER UP -------------------
            const powerBarWidth = 300;
            const powerBarHeight = 15;
            const powerBarX = W / 2 - powerBarWidth / 2;
            const powerBarY = H - 35; // M√°s bajo y separado

            let powerColor = '#FF00FF';
            let barFillWidth;
            let barText;

            if (santa.invincibleTimer > 0) {
                const durationRatio = santa.invincibleTimer / POWERUP_DURATION;
                barFillWidth = powerBarWidth * durationRatio;
                powerColor = (Math.floor(gameFrame / 5) % 2 === 0) ? '#00FFFF' : '#FF00FF';
                barText = `INVENCIBLE: ${Math.ceil(santa.invincibleTimer / 60)}s`;
            } else {
                const accumulationRatio = Math.min(1, enemiesDefeatedSincePowerUp / ENEMIES_FOR_POWERUP);
                barFillWidth = powerBarWidth * accumulationRatio;
                powerColor = '#FF00FF';
                barText = `POWER UP: ${enemiesDefeatedSincePowerUp}/${ENEMIES_FOR_POWERUP} ENEMIGOS`;
            }

            // Fondo de la barra de poder
            ctx.fillStyle = '#333333';
            ctx.fillRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);

            // Relleno de poder (con glow si est√° activo)
            ctx.fillStyle = powerColor;

            if (santa.invincibleTimer > 0) {
                ctx.shadowColor = powerColor;
                ctx.shadowBlur = 10;
            }
            ctx.fillRect(powerBarX, powerBarY, barFillWidth, powerBarHeight);

            // Restaurar sombras para el borde
            ctx.shadowBlur = 5;

            // Borde Doble
            ctx.strokeStyle = '#000000';
            ctx.strokeRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);
            ctx.strokeStyle = '#FFFFFF';
            ctx.strokeRect(powerBarX - 1, powerBarY - 1, powerBarWidth + 2, powerBarHeight + 2);

            // Restaurar sombras para el texto
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';

            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(barText, W / 2, powerBarY - 10);

            // Limpiar sombras para el resto del renderizado
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }


        // --- 7. BUCLE PRINCIPAL Y RESET ---

        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;


            if (gameState === 'TITLE') {
                drawTitleCharacters();
            } else if (gameState === 'PLAYING') {
                updateGame(deltaTime);
                drawGameObjects();
            }

            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            if (backgroundMusicSource) {
                try { backgroundMusicSource.stop(); } catch (e) {}
                backgroundMusicSource = null;
            }

            // CAMBIO CLAVE: Posici√≥n de Santa (Inferior Izquierda del √Årbol)
            santa.x = BASE_W / 2 - tree.size * 2;
            santa.y = BASE_H / 2 + tree.size * 2;

            santa.frame = 0;
            santa.health = santa.maxHealth;
            santa.invincible = false;
            santa.invincibleTimer = 0;
            santa.hitTimer = 0;
            tree.health = tree.maxHealth;
            tree.healingGlowTimer = 0;
            tree.damageGlitchTimer = 0;
            score = 0;
            lastHealScore = 0;
            enemies = [];
            bullets = [];
            explosions = [];
            floatingTexts = [];
            enemiesDefeatedSincePowerUp = 0;
            powerUpTimer = 0;
            gameFrame = 0;

            dialogue.message = "¬°Feliz Navidad! O como lo llama el 1%, 'Temporada de Consumo Forzado'.";
            dialogue.duration = PHRASE_DURATION;
            dialogue.powerUpMessage = null;
            timeSinceLastPhrase = 0;
            
            // NUEVO: Resetear la bomba
            bomba.active = false;
            lastBombaScore = 0;
        }

        // OCULTAR CONTROLES AL INICIO
        if (isMobile) {
            controls.style.display = 'none';
            shootButton.style.display = 'none';
        }
        audioToggle.style.display = 'none';

        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
