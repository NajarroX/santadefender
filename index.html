<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>EL SANTA DEFENDER</title>
<style>
/* --- FUENTES DE GOOGLE (Para t√≠tulo grueso y retro) --- */
@import url('https://fonts.googleapis.com/css2?family=Bungee+Inline&family=Press+Start+2P&display=swap');

/* --- ESTILOS BASE y AJUSTE DE VIEWPORT (Clave para eliminar scroll) --- */
body {
    margin: 0;
    padding: 0;
    background-color: #006600;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100dvh;
    font-family: 'Press Start 2P', monospace;
    position: relative;
}

/* --- PATR√ìN DE FONDO ANIMADO --- */
.background-pattern {
    position: fixed;
    top: 0;
    left: 0;
    width: 300%;
    height: 300%;
    z-index: 1;
    background:
        repeating-linear-gradient(
            45deg,
            transparent,
            transparent 40px,
            rgba(0, 0, 0, 0.1) 40px,
            rgba(0, 0, 0, 0.1) 80px
        ),
        repeating-linear-gradient(
            -45deg,
            #004d00,
            #004d00 30px,
            #00aa00 30px,
            #00aa00 60px
        );
    background-size: 150px 150px, 150px 150px;
    animation: movePattern 20s linear infinite;
}

.background-pattern.paused {
    animation-play-state: paused;
}

@keyframes movePattern {
    from { background-position: 0 0, 0 0; }
    to { background-position: 150px 150px, 150px 150px; }
}

/* --- T√çTULO PRINCIPAL (AHORA FIJO AL TOP) --- */
#mainTitle {
    font-family: 'Bungee Inline', sans-serif;
    color: white;
    text-align: center;
    line-height: 0.8;
    z-index: 30;
    text-shadow:
        -5px -5px 0 #000, 5px -5px 0 #000, -5px 5px 0 #000, 5px 5px 0 #000,
        0 0 10px #FF0000;
    position: fixed;
    top: 5%;
    left: 50%;
    transform: translateX(-50%);
    margin: 0;
    font-size: 80px;
}

/* Contenedor principal que centra el canvas */
#gameContainer {
    position: relative;
    z-index: 10;
    border: 4px solid #cc0000;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    width: 800px;
    height: 600px;
    max-width: 98vw;
    max-height: 98vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* Estilo del Canvas Base */
#gameCanvas {
    background-color: rgba(0, 102, 0, 0.85);
    touch-action: none;
    cursor: pointer;
    display: block;
    width: 100%;
    height: 100%;
}

/* --- Contenedor de elementos HTML de la Portada (ABSOLUTE EN EL BODY) --- */
.title-elements-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    min-height: 100%;
    z-index: 20;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    pointer-events: none;
    padding: 5vh 0 0;
}

/* Espaciador */
#characterAreaSpacer {
    flex-grow: 1;
    width: 100%;
}

/* Contenedor para el Bot√≥n y las Instrucciones */
#controlArea {
    pointer-events: auto;
    position: absolute;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    bottom: 40px;
}

/* --- Estilos del Bot√≥n de Inicio --- */
#startButton {
    pointer-events: auto;
    padding: 15px 30px;
    font-size: 30px;
    font-weight: bold;
    color: #FFFF00;
    background-color: #CC0000;
    border: 5px solid #000;
    box-shadow: 0 5px 0 #FF3333, 0 8px 0 #990000;
    cursor: pointer;
    text-align: center;
    margin-bottom: 15px;
    line-height: 1;
    user-select: none;
    font-family: 'Press Start 2P', monospace;
    z-index: 20;
    transition: all 0.1s ease;
}

#startButton:active {
    box-shadow: 0 2px 0 #FF3333, 0 5px 0 #990000;
    transform: translateY(3px);
}

/* --- Bloque de Instrucciones --- */
#instructions {
    pointer-events: auto;
    position: static;
    width: 600px;
    max-width: 85%;
    padding: 10px;
    background: rgba(34, 34, 34, 0.9);
    border: 3px solid #FFD700;
    color: #FFD700;
    z-index: 20;
    font-size: 14px;
    line-height: 1.5;
    text-align: center;
    margin-bottom: 15px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
}

#instructions h3 {
    margin-top: 0;
    color: #CC0000;
    font-size: 16px;
    border-bottom: 1px dashed #CC0000;
    padding-bottom: 5px;
}

#instructions p {
    margin: 5px 0;
    text-shadow: 1px 1px 2px black;
}

/* --- NUEVO: Modal personalizado para Game Over con Premios --- */
#gameOverModal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

#gameOverContent {
    background: linear-gradient(145deg, #006600, #004400);
    border: 8px solid #CC0000;
    padding: 40px;
    text-align: center;
    max-width: 700px;
    width: 90%;
    box-shadow: 0 0 50px rgba(255, 0, 0, 0.7);
    position: relative;
}

#gameOverContent::before {
    content: '';
    position: absolute;
    top: -15px;
    left: -15px;
    right: -15px;
    bottom: -15px;
    border: 4px solid #FFD700;
    z-index: -1;
}

#gameOverTitle {
    color: #FFD700;
    font-size: 36px;
    margin-bottom: 20px;
    text-shadow: 4px 4px 0 #000, 0 0 15px #FF0000;
}

#gameOverMessage {
    color: #FFFFFF;
    font-size: 18px;
    margin-bottom: 25px;
    line-height: 1.6;
    text-shadow: 2px 2px 0 #000;
}

#gameOverScore {
    color: #00FFFF;
    font-size: 24px;
    margin-bottom: 30px;
    text-shadow: 3px 3px 0 #000;
    background: rgba(0, 0, 0, 0.5);
    padding: 15px;
    border: 3px solid #FFD700;
}

#premiumButtonContainer {
    margin: 30px 0;
}

.premium-download-button {
    display: inline-block;
    padding: 20px 35px;
    background: linear-gradient(145deg, #CC0000, #990000);
    color: #FFFF00;
    border: 5px solid #000;
    font-family: 'Press Start 2P', monospace;
    font-size: 16px;
    cursor: pointer;
    text-decoration: none;
    transition: all 0.2s;
    box-shadow: 0 8px 0 #660000, 0 12px 0 #000;
    text-shadow: 3px 3px 0 #000;
    margin: 10px;
}

.premium-download-button:hover {
    background: linear-gradient(145deg, #FF0000, #CC0000);
    transform: translateY(-5px);
    box-shadow: 0 13px 0 #660000, 0 17px 0 #000;
}

.premium-download-button:active {
    transform: translateY(5px);
    box-shadow: 0 3px 0 #660000, 0 7px 0 #000;
}

#restartButton {
    margin-top: 20px;
    padding: 15px 30px;
    background: #333333;
    color: #FFFFFF;
    border: 4px solid #FFD700;
    font-family: 'Press Start 2P', monospace;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
}

#restartButton:hover {
    background: #555555;
    transform: scale(1.05);
}

/* --- RESPONSIVE GENERAL (Max 800px) --- */
@media (max-width: 800px) {
    #mainTitle {
        font-size: 40px;
        top: 20px;
        text-shadow:
            -3px -3px 0 #000, 3px -3px 0 #000, -3px 3px 0 #000, 3px 3px 0 #000,
            0 0 8px #FF0000;
    }
    
    .title-elements-container {
        padding: 2vh 0 0;
    }
    
    #controlArea {
        bottom: 30px;
    }
    
    #startButton {
        font-size: 20px;
        padding: 10px 20px;
        box-shadow: 0 4px 0 #FF3333, 0 6px 0 #990000;
    }
    
    #instructions {
        font-size: 10px;
        max-width: 90%;
    }
    
    #instructions h3 {
        font-size: 14px;
    }
    
    #audioToggle {
        font-size: 16px;
        padding: 5px 8px;
    }
    
    #gameOverContent {
        padding: 25px;
    }
    
    #gameOverTitle {
        font-size: 24px;
    }
    
    #gameOverMessage {
        font-size: 14px;
    }
    
    #gameOverScore {
        font-size: 18px;
    }
    
    .premium-download-button {
        padding: 15px 25px;
        font-size: 12px;
    }
}

/* --- CLAVE: AJUSTES ESPEC√çFICOS PARA M√ìVIL VERTICAL (pantallas muy estrechas/altas) --- */
@media (max-width: 600px) and (max-height: 800px) {
    #mainTitle {
        font-size: 32px;
        top: 10px;
    }
    
    .title-elements-container {
        padding: 1vh 0 0;
    }
    
    #controlArea {
        bottom: 20px;
    }
    
    #instructions {
        padding: 5px;
        font-size: 9px;
    }
    
    #instructions h3 {
        font-size: 12px;
    }
    
    #audioToggle {
        font-size: 14px;
        padding: 4px 6px;
    }
    
    #gameOverContent {
        padding: 20px;
    }
    
    #gameOverTitle {
        font-size: 20px;
    }
    
    #gameOverMessage {
        font-size: 12px;
    }
    
    #gameOverScore {
        font-size: 16px;
    }
    
    .premium-download-button {
        padding: 12px 20px;
        font-size: 10px;
    }
}

/* --- Control de Audio --- */
#audioToggle {
    position: fixed;
    top: 15px;
    left: 15px;
    z-index: 40;
    background: #000;
    color: #FFD700;
    border: 4px solid #CC0000;
    box-shadow: 0 0 10px #FF0000;
    border-radius: 0;
    padding: 8px 12px;
    font-size: 20px;
    cursor: pointer;
    user-select: none;
    display: none;
    pointer-events: auto;
    font-family: 'Press Start 2P', monospace;
}

#audioToggle:active {
    transform: scale(0.95);
}

.controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 40;
    display: none;
    pointer-events: auto;
}

.joystick-container {
    width: 150px;
    height: 150px;
    border-radius: 50%;
    background-color: rgba(34, 34, 34, 0.7);
    border: 3px solid #FFD700;
    box-shadow: inset 0 0 10px rgba(255, 255, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
}

.joystick-handle {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-color: #CC0000;
    border: 4px solid #FFD700;
    position: absolute;
    touch-action: none;
    box-shadow: 0 0 5px #FFFFFF;
}

.action-button {
    position: fixed;
    bottom: 50px;
    right: 50px;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: #00FFFF;
    border: 5px solid #000;
    color: #000;
    font-size: 1.2em;
    font-family: 'Press Start 2P', monospace;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
    box-shadow: 0 0 15px #00FFFF, inset 0 0 5px #FFFFFF;
    pointer-events: auto;
    display: none;
    z-index: 40;
}

.action-button:active {
    transform: scale(0.9);
    box-shadow: 0 0 5px #00FFFF, inset 0 0 5px #FFFFFF;
}
</style>
</head>
<body>

<div class="background-pattern" id="backgroundPattern"></div>
<h1 id="mainTitle">EL SANTA<br>DEFENDER</h1>

<div class="title-elements-container" id="titleElementsContainer">
    <div id="characterAreaSpacer"></div>
    <div id="controlArea">
        <div id="instructions"></div>
        <div id="startButton">¬°A DEFENDER!</div>
    </div>
</div>

<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>

<!-- NUEVO: Modal para Game Over con Premios -->
<div id="gameOverModal">
    <div id="gameOverContent">
        <h2 id="gameOverTitle">GAME OVER</h2>
        <p id="gameOverMessage"></p>
        <div id="gameOverScore"></div>
        <div id="premiumButtonContainer"></div>
        <button id="restartButton">JUGAR DE NUEVO</button>
    </div>
</div>

<button id="audioToggle">üîä</button>

<div class="controls" id="mobileControls">
    <div class="joystick-container" id="joystickContainer">
        <div class="joystick-handle" id="joystickHandle"></div>
    </div>
</div>

<div class="action-button" id="shootButton">FUEGO</div>

<script>
// --- 1. CONFIGURACI√ìN INICIAL Y DETECCI√ìN ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const BASE_W = 800;
const BASE_H = 600;
let W = BASE_W;
let H = BASE_H;
const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

// Estados del Juego
let gameState = 'TITLE';

// Referencias a elementos
const mainTitle = document.getElementById('mainTitle');
const startButton = document.getElementById('startButton');
const instructionsDiv = document.getElementById('instructions');
const gameContainer = document.getElementById('gameContainer');
const titleElementsContainer = document.getElementById('titleElementsContainer');
const backgroundPattern = document.getElementById('backgroundPattern');
const controls = document.getElementById('mobileControls');
const shootButton = document.getElementById('shootButton');
const joystickContainer = document.getElementById('joystickContainer');
const joystickHandle = document.getElementById('joystickHandle');
const audioToggle = document.getElementById('audioToggle');

// NUEVO: Referencias para el modal de Game Over con Premios
const gameOverModal = document.getElementById('gameOverModal');
const gameOverTitle = document.getElementById('gameOverTitle');
const gameOverMessage = document.getElementById('gameOverMessage');
const gameOverScore = document.getElementById('gameOverScore');
const premiumButtonContainer = document.getElementById('premiumButtonContainer');
const restartButton = document.getElementById('restartButton');

// Constantes del juego
const PLAYER_SPEED = 4;
const BULLET_SPEED = 8;
const JOYSTICK_RADIUS = 75;
const PHRASE_DURATION = 300;
const PHRASE_INTERVAL = 8000;
const HIT_DURATION = 10;
const GLITCH_DURATION = 15;
const ENEMIES_FOR_POWERUP = 10;
const POWERUP_DURATION = 300;
const INVINCIBILITY_PHRASE_DURATION = 90;
const INVINCIBILITY_PHRASE_CHANCE = 0.40;
const ENEMY_TYPES = [
    { speed: 1.5, color: '#666666', spawnWeight: 60 },
    { speed: 2.5, color: '#990000', spawnWeight: 30 },
    { speed: 1.0, color: '#000066', spawnWeight: 10 }
];
let spawnRate = 0.02;
const HEAL_SCORE_HIT = 1000;
let lastHealScore = 0;
const GLOW_DURATION = 30;

// NUEVO: Constantes para premios
const PREMIO_1_PUNTAJE = 1000;
const PREMIO_2_PUNTAJE = 2000;
const PREMIO_3_PUNTAJE = 3000;

// REEMPLAZA ESTOS IDs CON LOS DE TUS ARCHIVOS REALES EN GOOGLE DRIVE
const PDF_URLS = {
    1000: 'https://drive.google.com/uc?export=download&id=1-Zu4na5y9GBs9S3EOsbvai8-rLlT2M-u',
    2000: 'https://drive.google.com/uc?export=download&id=1aIwUHL3_N1kUkFiKnw54eampLpfB2iml', 
    3000: 'https://drive.google.com/uc?export=download&id=1y8-vpZ4HacqPq4LqdfVh_s1iSDb7mvvO'
};

// NUEVO: Constantes para BOMBA
const BOMBA_SCORE_HIT = 500;
const BOMBA_DURATION = 420;
const BOMBA_SIZE = 35;

// Objetos del juego
let santa = {
    x: BASE_W / 2, y: BASE_H / 2, size: 20, color: 'red', health: 10, maxHealth: 10,
    dirX: 0, dirY: 0, shooting: false, lastShotTime: 0, fireRate: 200, frame: 0,
    invincible: false, invincibleTimer: 0, hitTimer: 0
};
const ENEMY_BASE_SIZE = 18;
let tree = {
    x: BASE_W / 2, y: BASE_H / 2, size: 40, color: '#00aa00', health: 50, maxHealth: 50,
    healingGlowTimer: 0, damageGlitchTimer: 0
};
const treeHealthMax = tree.maxHealth;

let bullets = [];
let enemies = [];
let explosions = [];
let floatingTexts = [];
let score = 0;
let enemiesDefeatedSincePowerUp = 0;
let powerUpTimer = 0;
let gameFrame = 0;
let dialogue = {
    message: "¬°Feliz Navidad! O como lo llama el 1%, 'Temporada de Consumo Forzado'.",
    duration: PHRASE_DURATION, powerUpMessage: null
};
const invincibilityPhrases = [
    "¬°Fuera de aqu√≠, par√°sitos capitalistas!",
    "¬°El capital no puede con la magia de un Santa sindicalizado!",
    "¬°El √∫nico regago que dar√© es esta paliza! ¬°Por un Polo Norte libre de explotaci√≥n!"
];
const sarcasticPhrases = [
    { min: 40, phrases: [
        "¬°Luchando por el √°rbol, el √∫nico bien p√∫blico que queda en pie!",
        "¬°Mis elfos no tienen sindicato, son la verdadera tragedia aqu√≠, no estos demonios!",
        "¬°La avaricia ha creado monstruos... literalmente! ¬°Que iron√≠a!",
        "¬°El precio de la hora extra es lo que realmente duele, no sus mordiscos!",
        "¬°Defender este √°rbol es la nueva 'responsabilidad social corporativa'!"
    ]},
    { min: 25, phrases: [
        "¬øEn serio? ¬øTantos enemigos y la riqueza sigue concentrada en los de arriba?",
        "¬°Esto es lo que pasa cuando privatizas el Polo Norte!",
        "¬°No hay suficientes incentivos fiscales para seguir con esta masacre!",
        "¬°Al menos estos monstruos trabajan, a diferencia de los par√°sitos de la junta directiva!",
        "¬°Mi n√≥mina est√° congelada, pero mi furia no!"
    ]},
    { min: 1, phrases: [
        "¬°La recesi√≥n de salud lleg√≥ antes de lo esperado! ¬°S√°lvese quien pueda!",
        "¬°Parece que el mercado se est√° 'ajustando' a la baja, justo como mi moral!",
        "¬°Si perdemos, que el √°rbol se declare en bancarrota para salvar mis activos!",
        "¬°La pr√≥xima Navidad, los juguetes ser√°n hechos por la IA... y ser√°n a√∫n m√°s caros!",
        "¬°El verdadero regalo es un sistema que funcione, no m√°s juguetes!"
    ]}
];
let timeSinceLastPhrase = 0;

// NUEVO: Variables para BOMBA
let bomba = {
    active: false,
    x: 0,
    y: 0,
    timer: 0,
    frame: 0
};
let lastBombaScore = 0;

// Audio
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const masterGain = audioContext.createGain();
masterGain.connect(audioContext.destination);
let isMuted = false;
let backgroundMusicSource = null;
const C4 = 261.63, D4 = 293.66, E4 = 329.63, F4 = 349.23, G4 = 392.00, A4 = 440.00;
const tempo = 0.25;
const melody = [
    { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
    { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
    { freq: E4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: C4, duration: 0.5 }, { freq: D4, duration: 0.5 },
    { freq: E4, duration: 2.0 },
    { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 },
    { freq: F4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.25 }, { freq: D4, duration: 0.25 },
    { freq: D4, duration: 0.5 }, { freq: D4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: D4, duration: 0.5 },
    { freq: G4, duration: 2.0 },
    { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
    { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
    { freq: E4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: C4, duration: 0.5 }, { freq: D4, duration: 0.5 },
    { freq: E4, duration: 2.0 },
    { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 },
    { freq: F4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.25 }, { freq: D4, duration: 0.25 },
    { freq: G4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: D4, duration: 0.5 },
    { freq: C4, duration: 2.0 }
];

function startBackgroundMusic() {
    if (backgroundMusicSource) {
        if (backgroundMusicSource.playbackState === backgroundMusicSource.PLAYING_STATE) {
            try { backgroundMusicSource.stop(audioContext.currentTime); } catch (e) {}
        }
        backgroundMusicSource = null;
    }
    
    const playSequence = (time) => {
        if (gameState !== 'PLAYING' || isMuted) {
            backgroundMusicSource = null;
            return;
        }
        
        let currentTime = time;
        backgroundMusicSource = audioContext.createOscillator();
        backgroundMusicSource.type = 'square';
        const musicGain = audioContext.createGain();
        musicGain.gain.setValueAtTime(0.4, audioContext.currentTime);
        backgroundMusicSource.connect(musicGain);
        musicGain.connect(masterGain);
        
        melody.forEach(note => {
            const duration = note.duration * tempo;
            if (note.freq > 0) {
                backgroundMusicSource.frequency.setValueAtTime(note.freq, currentTime);
                musicGain.gain.setValueAtTime(0.4, currentTime);
                musicGain.gain.exponentialRampToValueAtTime(0.0001, currentTime + duration * 0.95);
            } else {
                musicGain.gain.setValueAtTime(0.0001, currentTime);
            }
            currentTime += duration;
        });
        
        backgroundMusicSource.start(time);
        backgroundMusicSource.stop(currentTime);
        backgroundMusicSource.onended = () => {
            if (gameState === 'PLAYING' && !isMuted) {
                playSequence(audioContext.currentTime);
            } else {
                backgroundMusicSource = null;
            }
        };
    };
    
    playSequence(audioContext.currentTime);
}

function playSound(frequency, duration, type, endFrequency = frequency, volume = 0.5) {
    if (isMuted) return;
    if (audioContext.state === 'suspended') {
        audioContext.resume();
    }
    
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
    
    if (endFrequency !== frequency) {
        oscillator.frequency.linearRampToValueAtTime(endFrequency, audioContext.currentTime + duration);
    }
    
    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);
    oscillator.connect(gainNode);
    gainNode.connect(masterGain);
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration);
}

function playExplosion(pitch) {
    playSound(pitch, 0.1, 'triangle', pitch * 0.5, 0.6);
}

function playBombaSound() {
    playSound(150, 0.3, 'sawtooth', 50, 0.8);
}

function playPowerUpSound() {
    playSound(300, 0.2, 'square', 700, 0.7);
}

function playHealSound() {
    playSound(400, 0.15, 'sine', 800, 0.8);
}

// NUEVO: Sonido para premio
function playPremioSound() {
    playSound(600, 0.3, 'sine', 900, 1.0);
}

function toggleAudio() {
    isMuted = !isMuted;
    if (isMuted) {
        masterGain.gain.setValueAtTime(0, audioContext.currentTime);
        audioToggle.textContent = 'üîá';
        if (backgroundMusicSource) {
            try { backgroundMusicSource.stop(audioContext.currentTime); } catch (e) {}
            backgroundMusicSource = null;
        }
    } else {
        masterGain.gain.setValueAtTime(1, audioContext.currentTime);
        audioToggle.textContent = 'üîä';
        if (gameState === 'PLAYING' && !backgroundMusicSource) {
            startBackgroundMusic();
        }
    }
}

audioToggle.addEventListener('click', toggleAudio);
window.addEventListener('keydown', (e) => {
    if (e.code === 'Tab' && gameState === 'PLAYING') {
        e.preventDefault();
        toggleAudio();
    }
});

// --- CLASE EXPLOSI√ìN ---
class Explosion {
    constructor(x, y, color) {
        this.particles = [];
        for (let i = 0; i < 10; i++) {
            this.particles.push({
                x: x,
                y: y,
                size: Math.random() * 4 + 2,
                color: color,
                vx: Math.random() * 6 - 3,
                vy: Math.random() * 6 - 3,
                life: 30
            });
        }
    }
    
    update() {
        this.particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
        });
        this.particles = this.particles.filter(p => p.life > 0);
        return this.particles.length > 0;
    }
    
    draw() {
        this.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        });
    }
}

// NUEVO: Clase para explosi√≥n grande de la bomba
class BigExplosion {
    constructor(x, y, color) {
        this.particles = [];
        for (let i = 0; i < 30; i++) {
            this.particles.push({
                x: x,
                y: y,
                size: Math.random() * 6 + 3,
                color: color,
                vx: Math.random() * 10 - 5,
                vy: Math.random() * 10 - 5,
                life: 45
            });
        }
    }
    
    update() {
        this.particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
        });
        this.particles = this.particles.filter(p => p.life > 0);
        return this.particles.length > 0;
    }
    
    draw() {
        this.particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        });
    }
}

// --- CLASE PARA TEXTOS FLOTANTES ---
class FloatingText {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.vy = -1.5;
        this.life = 60;
        this.maxLife = 60;
    }
    
    update() {
        this.y += this.vy;
        this.life--;
        return this.life > 0;
    }
    
    draw() {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.font = '24px monospace';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 3;
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
    }
}

// --- 3. RESPONSIVE DESIGN Y MANEJO DE VENTANA ---
function resizeGame() {
    const viewportW = window.innerWidth;
    const viewportH = window.innerHeight;
    const aspectR = BASE_W / BASE_H;
    let newW, newH;
    const maxContainerW = viewportW * 0.98;
    const maxContainerH = viewportH * 0.98;
    
    if (maxContainerW / maxContainerH > aspectR) {
        newH = maxContainerH;
        newW = maxContainerH * aspectR;
    } else {
        newW = maxContainerW;
        newH = maxContainerW / aspectR;
    }
    
    gameContainer.style.width = newW + 'px';
    gameContainer.style.height = newH + 'px';
    W = BASE_W;
    H = BASE_H;
    canvas.width = W;
    canvas.height = H;
}

window.addEventListener('resize', resizeGame);
resizeGame();

// --- 4. MANEJO DE EVENTOS ---
function handleStartGame() {
    if (gameState === 'TITLE') {
        audioContext.resume();
        playSound(440, 0.01, 'sine', 440, 0);
        gameState = 'PLAYING';
        titleElementsContainer.style.display = 'none';
        mainTitle.style.display = 'none';
        backgroundPattern.classList.add('paused');
        resetGame();
        startBackgroundMusic();
        
        if (isMobile) {
            controls.style.display = 'block';
            shootButton.style.display = 'flex';
        }
        audioToggle.style.display = 'block';
    }
}

startButton.addEventListener('click', handleStartGame);
startButton.addEventListener('touchstart', (e) => {
    e.preventDefault();
    handleStartGame();
});

function fillInstructions() {
    const instructionsContent = isMobile ?
        `<h3>CONTROLES M√ìVIL</h3>
         <p><strong>Joystick:</strong> Mover a Santa</p>
         <p><strong>FUEGO:</strong> Disparar</p>
         <p><strong>BOMBA:</strong> ¬°Colecciona cada 500 pts!</p>
         <p><strong>PREMIOS:</strong> +1,000 +2,000 +3,000 pts</p>
         <p><strong>Meta:</strong> ¬°Defiende el √Årbol!</p>` :
        `<h3>CONTROLES PC</h3>
         <p><strong>WASD / Flechas:</strong> Mover</p>
         <p><strong>Espacio / Click Izq:</strong> Disparar</p>
         <p><strong>TAB:</strong> Silenciar Audio</p>
         <p><strong>BOMBA:</strong> ¬°Colecciona cada 500 pts!</p>
         <p><strong>PREMIOS:</strong> +1,000 +2,000 +3,000 pts</p>
         <p><strong>Meta:</strong> ¬°Defiende el √Årbol!</p>`;
    instructionsDiv.innerHTML = instructionsContent;
}

fillInstructions();

// --- NUEVO: SISTEMA DE PREMIOS EN GAME OVER ---
function determinarPremio(puntos) {
    if (puntos >= PREMIO_3_PUNTAJE) {
        return {
            nivel: 3,
            mensaje: "¬°LEGENDARIO DEFENSOR! Has superado los 3,000 puntos. ¬°Eres una verdadera leyenda del Polo Norte!",
            archivo: "Santadefender-premio3.pdf",
            textoBoton: "DESCARGAR PREMIO 3 - LEYENDA",
            url: PDF_URLS[3000]
        };
    } else if (puntos >= PREMIO_2_PUNTAJE) {
        return {
            nivel: 2,
            mensaje: "¬°GRAN DEFENSOR! Has alcanzado m√°s de 2,000 puntos. ¬°Tu habilidad es impresionante!",
            archivo: "Santadefender-premio2.pdf",
            textoBoton: "DESCARGAR PREMIO 2 - EXPERTO",
            url: PDF_URLS[2000]
        };
    } else if (puntos >= PREMIO_1_PUNTAJE) {
        return {
            nivel: 1,
            mensaje: "¬°BUEN DEFENSOR! Has superado los 1,000 puntos. ¬°Sigue as√≠!",
            archivo: "Santadefender-premio1.pdf",
            textoBoton: "DESCARGAR PREMIO 1 - NOVATO",
            url: PDF_URLS[1000]
        };
    } else {
        return {
            nivel: 0,
            mensaje: "¬°Sigue practicando! Intenta llegar a los 1,000 puntos para ganar tu primer premio.",
            archivo: null,
            textoBoton: null,
            url: null
        };
    }
}

function mostrarGameOverConPremio(razon) {
    // Detener m√∫sica
    if (backgroundMusicSource) {
        try { backgroundMusicSource.stop(); } catch (e) {}
        backgroundMusicSource = null;
    }
    
    // Determinar premio seg√∫n puntaje
    const premio = determinarPremio(score);
    
    // Configurar mensajes
    let mensajeFinal = "";
    if (razon === 'santa') {
        mensajeFinal = `¬°Santa ha sido sobrepasado!<br>${premio.mensaje}`;
    } else {
        mensajeFinal = `¬°El √°rbol ha sido talado!<br>${premio.mensaje}`;
    }
    
    gameOverMessage.innerHTML = mensajeFinal;
    gameOverScore.textContent = `PUNTUACI√ìN FINAL: ${score} PUNTOS`;
    
    // Limpiar botones anteriores
    premiumButtonContainer.innerHTML = "";
    
    // Agregar bot√≥n de premio si corresponde
    if (premio.nivel > 0) {
        const botonPremio = document.createElement('a');
        botonPremio.href = premio.url;
        botonPremio.target = "_blank";
        botonPremio.download = premio.archivo;
        botonPremio.className = "premium-download-button";
        botonPremio.textContent = premio.textoBoton;
        premiumButtonContainer.appendChild(botonPremio);
        
        // Reproducir sonido de premio
        playPremioSound();
    }
    
    // Mostrar modal
    gameOverModal.style.display = "flex";
    
    // Pausar animaci√≥n de fondo
    backgroundPattern.classList.remove('paused');
}

// Evento para reiniciar juego
restartButton.addEventListener('click', () => {
    gameOverModal.style.display = "none";
    gameState = 'TITLE';
    resetGame();
    titleElementsContainer.style.display = 'flex';
    mainTitle.style.display = 'block';
    
    if (isMobile) {
        controls.style.display = 'none';
        shootButton.style.display = 'none';
    }
    audioToggle.style.display = 'none';
});

// Cerrar modal si se hace clic fuera del contenido
gameOverModal.addEventListener('click', (e) => {
    if (e.target === gameOverModal) {
        gameOverModal.style.display = "none";
        gameState = 'TITLE';
        resetGame();
        titleElementsContainer.style.display = 'flex';
        mainTitle.style.display = 'block';
        
        if (isMobile) {
            controls.style.display = 'none';
            shootButton.style.display = 'none';
        }
        audioToggle.style.display = 'none';
    }
});

// --- Controles de juego ---
let keys = {};
if (!isMobile) {
    window.addEventListener('keydown', (e) => {
        if (gameState === 'PLAYING') {
            keys[e.code] = true;
        }
    });
    
    window.addEventListener('keyup', (e) => {
        if (gameState === 'PLAYING') {
            keys[e.code] = false;
            if (e.code === 'Space') santa.shooting = false;
        }
    });
    
    window.addEventListener('mousedown', (e) => {
        if (e.button === 0 && gameState === 'PLAYING') santa.shooting = true;
    });
    
    window.addEventListener('mouseup', (e) => {
        if (e.button === 0 && gameState === 'PLAYING') santa.shooting = false;
    });
}

let joystickActive = false;
let startX, startY;

if (isMobile) {
    joystickContainer.addEventListener('touchstart', (e) => {
        if (gameState !== 'PLAYING') return;
        e.preventDefault();
        joystickActive = true;
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
    });
    
    joystickContainer.addEventListener('touchmove', (e) => {
        if (!joystickActive || gameState !== 'PLAYING') return;
        const touch = e.touches[0];
        const rect = joystickContainer.getBoundingClientRect();
        const deltaX = (touch.clientX - rect.left - rect.width / 2);
        const deltaY = (touch.clientY - rect.top - rect.height / 2);
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        let finalX = deltaX;
        let finalY = deltaY;
        
        if (distance > JOYSTICK_RADIUS) {
            finalX = (deltaX / distance) * JOYSTICK_RADIUS;
            finalY = (deltaY / distance) * JOYSTICK_RADIUS;
        }
        
        joystickHandle.style.transform = `translate(${finalX}px, ${finalY}px)`;
        santa.dirX = finalX / JOYSTICK_RADIUS;
        santa.dirY = finalY / JOYSTICK_RADIUS;
    });
    
    const resetJoystick = () => {
        joystickActive = false;
        santa.dirX = 0;
        santa.dirY = 0;
        joystickHandle.style.transform = `translate(0px, 0px)`;
    };
    
    joystickContainer.addEventListener('touchend', resetJoystick);
    joystickContainer.addEventListener('touchcancel', resetJoystick);
    
    shootButton.addEventListener('touchstart', (e) => {
        if (gameState !== 'PLAYING') return;
        e.preventDefault();
        santa.shooting = true;
    });
    
    shootButton.addEventListener('touchend', (e) => {
        if (gameState !== 'PLAYING') return;
        e.preventDefault();
        santa.shooting = false;
    });
}

// --- 5. L√ìGICA DEL JUEGO ---
function handleShooting(deltaTime) {
    const currentFireRate = (santa.invincibleTimer > 0) ? 50 : santa.fireRate;
    if ((!isMobile && (keys['Space'] || santa.shooting)) || 
        (isMobile && santa.shooting) || 
        (santa.invincibleTimer > 0)) {
        
        const currentTime = Date.now();
        if (currentTime - santa.lastShotTime > currentFireRate) {
            const dx = tree.x - santa.x;
            const dy = tree.y - santa.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const nx = dx / dist;
            const ny = dy / dist;
            
            bullets.push({
                x: santa.x,
                y: santa.y,
                size: (santa.invincibleTimer > 0) ? 12 : 8,
                color: (santa.invincibleTimer > 0) ? '#00FFFF' : 'yellow',
                dirX: nx,
                dirY: ny
            });
            
            santa.lastShotTime = currentTime;
            playSound(700, 0.05, 'square');
        }
    }
}

function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.x += bullet.dirX * BULLET_SPEED;
        bullet.y += bullet.dirY * BULLET_SPEED;
        
        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            if (checkCollision(bullet, enemy)) {
                explosions.push(new Explosion(enemy.x, enemy.y, enemy.color));
                floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+10', '#00FFFF'));
                enemies.splice(j, 1);
                bullets.splice(i, 1);
                score += 10;
                enemiesDefeatedSincePowerUp++;
                playExplosion(300);
                hit = true;
                break;
            }
        }
        
        if (!hit && (bullet.x < 0 || bullet.x > W || bullet.y < 0 || bullet.y > H)) {
            bullets.splice(i, 1);
        }
    }
}

function updatePowerUp(deltaTime) {
    if (santa.invincibleTimer > 0) {
        santa.invincibleTimer -= (deltaTime / (1000 / 60));
        if (santa.invincibleTimer <= 0) {
            santa.invincible = false;
            santa.invincibleTimer = 0;
            dialogue.message = "¬°Se agot√≥ la invencibilidad!";
            dialogue.duration = PHRASE_DURATION;
            dialogue.powerUpMessage = null;
        }
    }
    
    if (enemiesDefeatedSincePowerUp >= ENEMIES_FOR_POWERUP) {
        santa.health = santa.maxHealth;
        santa.invincible = true;
        santa.invincibleTimer = POWERUP_DURATION;
        enemiesDefeatedSincePowerUp = 0;
        dialogue.powerUpMessage = invincibilityPhrases[Math.floor(Math.random() * invincibilityPhrases.length)];
        dialogue.message = dialogue.powerUpMessage;
        dialogue.duration = INVINCIBILITY_PHRASE_DURATION;
        playSound(300, 0.2, 'sawtooth', 700);
    }
}

function checkHealHit() {
    if (score >= lastHealScore + HEAL_SCORE_HIT) {
        lastHealScore += HEAL_SCORE_HIT;
        const healAmount = tree.maxHealth * 0.5;
        const oldHealth = tree.health;
        const newHealth = Math.min(tree.maxHealth, tree.health + healAmount);
        
        if (newHealth > oldHealth) {
            tree.health = newHealth;
            dialogue.message = `¬°HITO! El √°rbol se ha regenerado un 50%. HP: ${tree.health}`;
            dialogue.duration = PHRASE_DURATION;
            tree.healingGlowTimer = GLOW_DURATION;
            playHealSound();
        }
    }
}

// NUEVO: Funciones para BOMBA
function checkBombaSpawn() {
    if (score >= lastBombaScore + BOMBA_SCORE_HIT && !bomba.active) {
        lastBombaScore += BOMBA_SCORE_HIT;
        bomba.x = Math.random() * (W - 100) + 50;
        bomba.y = Math.random() * (H - 100) + 50;
        bomba.active = true;
        bomba.timer = BOMBA_DURATION;
        bomba.frame = 0;
        dialogue.message = "¬°UN ELFO CON BOMBA HA APARECIDO! ¬°COLISIONA CON √âL!";
        dialogue.duration = PHRASE_DURATION;
        playPowerUpSound();
    }
}

function updateBomba(deltaTime) {
    if (bomba.active) {
        bomba.timer--;
        bomba.frame = (bomba.frame + 0.1) % 4;
        
        if (bomba.timer <= 0) {
            bomba.active = false;
            dialogue.message = "¬°La bomba ha desaparecido! Espera otros 500 pts.";
            dialogue.duration = PHRASE_DURATION;
        }
        
        if (checkCollision(santa, {x: bomba.x, y: bomba.y, size: BOMBA_SIZE})) {
            activateBomba();
        }
    }
}

function activateBomba() {
    let enemiesDestroyed = 0;
    
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        explosions.push(new BigExplosion(enemy.x, enemy.y, '#FF0000'));
        floatingTexts.push(new FloatingText(enemy.x, enemy.y, '+50', '#FFFF00'));
        score += 50;
        enemiesDefeatedSincePowerUp++;
        enemiesDestroyed++;
        playExplosion(200 + i * 20);
    }
    
    enemies = [];
    explosions.push(new BigExplosion(bomba.x, bomba.y, '#FF9900'));
    dialogue.message = `¬°BOOM! ${enemiesDestroyed} enemigos destruidos. +${enemiesDestroyed * 50} pts!`;
    dialogue.duration = PHRASE_DURATION;
    playBombaSound();
    bomba.active = false;
    
    if (enemiesDefeatedSincePowerUp >= ENEMIES_FOR_POWERUP) {
        santa.health = santa.maxHealth;
        santa.invincible = true;
        santa.invincibleTimer = POWERUP_DURATION;
        enemiesDefeatedSincePowerUp = 0;
        dialogue.powerUpMessage = "¬°BOMBA PLUS! ¬°Invencibilidad activada!";
        dialogue.message = dialogue.powerUpMessage;
        dialogue.duration = INVINCIBILITY_PHRASE_DURATION;
        playSound(300, 0.2, 'sawtooth', 700);
    }
}

function updatePlayerMovement() {
    const originalY = BASE_H / 2 + santa.y - (BASE_H / 2);
    
    if (!isMobile) {
        santa.dirX = 0;
        santa.dirY = 0;
        if (keys['KeyA'] || keys['ArrowLeft']) santa.dirX = -1;
        if (keys['KeyD'] || keys['ArrowRight']) santa.dirX = 1;
        if (keys['KeyW'] || keys['ArrowUp']) santa.dirY = -1;
        if (keys['KeyS'] || keys['ArrowDown']) santa.dirY = 1;
    }
    
    const magnitude = Math.sqrt(santa.dirX * santa.dirX + santa.dirY * santa.dirY);
    
    if (santa.hitTimer > 0) {
        santa.y -= 3 * (santa.hitTimer / HIT_DURATION);
        santa.hitTimer--;
    }
    
    if (magnitude === 0 && santa.hitTimer === 0) {
        santa.y += Math.sin(gameFrame * 0.05) * 0.2;
        santa.frame = 0;
    } else if (santa.hitTimer === 0) {
        const nx = santa.dirX / magnitude;
        const ny = santa.dirY / magnitude;
        const speed = (santa.invincibleTimer > 0) ? PLAYER_SPEED * 1.5 : PLAYER_SPEED;
        santa.x += nx * speed;
        santa.y += ny * speed;
        santa.frame = (santa.frame + 0.1) % 2;
    }
    
    santa.x = Math.max(santa.size / 2, Math.min(W - santa.size / 2, santa.x));
    santa.y = Math.max(santa.size / 2, Math.min(H - santa.size / 2, santa.y));
}

function updateExplosions() {
    for (let i = explosions.length - 1; i >= 0; i--) {
        if (!explosions[i].update()) {
            explosions.splice(i, 1);
        }
    }
}

function updateFloatingTexts() {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        if (!floatingTexts[i].update()) {
            floatingTexts.splice(i, 1);
        }
    }
}

function spawnEnemies() {
    if (Math.random() < spawnRate) {
        let totalWeight = ENEMY_TYPES.reduce((sum, type) => sum + type.spawnWeight, 0);
        let randomValue = Math.random() * totalWeight;
        let selectedType = ENEMY_TYPES[0];
        
        for (const type of ENEMY_TYPES) {
            randomValue -= type.spawnWeight;
            if (randomValue <= 0) {
                selectedType = type;
                break;
            }
        }
        
        const size = ENEMY_BASE_SIZE;
        const edge = Math.floor(Math.random() * 4);
        let x, y;
        
        switch (edge) {
            case 0: x = Math.random() * W; y = -size; break;
            case 1: x = W + size; y = Math.random() * H; break;
            case 2: x = Math.random() * W; y = H + size; break;
            case 3: x = -size; y = Math.random() * H; break;
        }
        
        enemies.push({
            x: x,
            y: y,
            size: size,
            color: selectedType.color,
            speed: selectedType.speed,
            walkFrame: 0
        });
    }
}

function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const dx = tree.x - enemy.x;
        const dy = tree.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const nx = dx / dist;
        const ny = dy / dist;
        
        enemy.x += nx * enemy.speed;
        enemy.y += ny * enemy.speed;
        enemy.walkFrame = (enemy.walkFrame + 0.1 * enemy.speed) % 3;
        
        let destroyed = false;
        
        if (checkCollision(enemy, santa)) {
            if (!santa.invincible) {
                santa.health -= 1;
                santa.hitTimer = HIT_DURATION;
                explosions.push(new Explosion(enemy.x, enemy.y, 'white'));
                playSound(150, 0.1, 'square', 100);
                
                if (santa.health <= 0) {
                    // NUEVO: Mostrar modal de Game Over con premio
                    mostrarGameOverConPremio('santa');
                    gameState = 'GAME_OVER';
                    return;
                }
            } else {
                explosions.push(new Explosion(enemy.x, enemy.y, '#FF00FF'));
            }
            enemies.splice(i, 1);
            destroyed = true;
        }
        
        if (!destroyed && checkCollision(enemy, tree)) {
            tree.health -= 1;
            tree.damageGlitchTimer = GLITCH_DURATION;
            enemies.splice(i, 1);
            floatingTexts.push(new FloatingText(tree.x, tree.y - tree.size * 0.8, '-1', '#FF0000'));
            explosions.push(new Explosion(enemy.x, enemy.y, '#990000'));
            
            if (tree.health <= 0) {
                // NUEVO: Mostrar modal de Game Over con premio
                mostrarGameOverConPremio('arbol');
                gameState = 'GAME_OVER';
                return;
            }
        }
    }
}

function updateDialogue(deltaTime) {
    if (dialogue.duration > 0) {
        dialogue.duration -= (deltaTime / (1000 / 60));
    }
    
    if (santa.invincibleTimer > 0 && dialogue.powerUpMessage && dialogue.duration <= 0) {
        if (Math.random() < INVINCIBILITY_PHRASE_CHANCE) {
            dialogue.message = dialogue.powerUpMessage;
            dialogue.duration = INVINCIBILITY_PHRASE_DURATION;
        }
        return;
    }
    
    timeSinceLastPhrase += deltaTime;
    
    if (timeSinceLastPhrase > PHRASE_INTERVAL && dialogue.duration <= 0 && santa.invincibleTimer <= 0) {
        let eligiblePhrases = [];
        for(const group of sarcasticPhrases) {
            if (tree.health >= group.min) {
                eligiblePhrases = group.phrases;
                break;
            }
        }
        
        if (eligiblePhrases.length > 0) {
            const newPhrase = eligiblePhrases[Math.floor(Math.random() * eligiblePhrases.length)];
            dialogue.message = newPhrase;
            dialogue.duration = PHRASE_DURATION;
            timeSinceLastPhrase = 0;
        }
    }
}

function checkCollision(objA, objB) {
    const sizeA = objA.size || 0;
    const sizeB = objB.size || 0;
    const overlap = 0.8;
    
    return objA.x < objB.x + sizeB * overlap &&
           objA.x + sizeA * overlap > objB.x &&
           objA.y < objB.y + sizeB * overlap &&
           objA.y + sizeA * overlap > objB.y;
}

function updateGame(deltaTime) {
    updatePlayerMovement();
    updatePowerUp(deltaTime);
    handleShooting(deltaTime);
    updateBullets();
    updateExplosions();
    updateFloatingTexts();
    spawnEnemies();
    updateEnemies();
    updateDialogue(deltaTime);
    checkHealHit();
    checkBombaSpawn();
    updateBomba(deltaTime);
    gameFrame++;
    
    if (tree.healingGlowTimer > 0) {
        tree.healingGlowTimer--;
    }
    
    if (tree.damageGlitchTimer > 0) {
        tree.damageGlitchTimer--;
    }
}

// --- 6. RENDERIZADO ---
function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x - w / 2, y - h / 2, w, h);
}

function drawCircle(x, y, r, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
}

function drawShadow(x, y, width, height, opacity = 0.35) {
    ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
    ctx.beginPath();
    ctx.ellipse(x, y, width / 2, height * 0.4 / 2, 0, 0, Math.PI * 2);
    ctx.fill();
}

function drawSanta(x, y, size, frame) {
    if (santa.invincible && Math.floor(santa.invincibleTimer / 5) % 2 === 0) {
        return;
    }
    
    const s = size;
    const halfS = s / 2;
    const p = s / 20;
    drawShadow(x, y + halfS + p * 6, s * 1.4, s * 0.8);
    
    let legOffset = 0;
    if (santa.dirX !== 0 || santa.dirY !== 0) {
        legOffset = (Math.floor(frame) === 0) ? s * 0.15 : -s * 0.15;
    }
    
    let bodyOffset = 0;
    if (santa.hitTimer > 0) {
        bodyOffset = -s * 0.1;
    }
    
    const headYOffset = -s * 0.2;
    const bodyYOffset = -s * 0.1;
    
    drawRect(x, y - halfS + p * 2 + headYOffset, s * 0.9, s * 0.4, 'red');
    drawCircle(x + s * 0.35, y - halfS + p + headYOffset, s * 0.15, 'white');
    drawRect(x, y - halfS + p * 5 + headYOffset, s, p * 2, 'white');
    drawRect(x, y - s * 0.1 + headYOffset, s * 0.4, s * 0.2, '#FFDBAC');
    drawRect(x - s * 0.1, y - s * 0.2 + headYOffset, p, p, 'black');
    drawRect(x + s * 0.1, y - s * 0.2 + headYOffset, p, p, 'black');
    drawRect(x, y + s * 0.2 + headYOffset, s * 1.2, s * 0.4, 'white');
    drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.8, s * 0.35, 'red');
    drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.8, s * 0.1, 'black');
    drawRect(x, y + s * 0.6 + bodyYOffset + bodyOffset, s * 0.2, s * 0.15, '#FFD700');
    drawRect(x - s * 0.2 + legOffset, y + s * 0.85 + bodyYOffset, s * 0.15, s * 0.2, 'black');
    drawRect(x + s * 0.2 + legOffset, y + s * 0.85 + bodyYOffset, s * 0.15, s * 0.2, 'black');
}

// NUEVO: Dibujar el elfo con bomba
function drawBomba() {
    if (!bomba.active) return;
    
    const x = bomba.x;
    const y = bomba.y;
    const s = BOMBA_SIZE;
    const halfS = s / 2;
    const p = s / 20;
    
    drawShadow(x, y + halfS + 4, s * 1.2, s * 0.8);
    
    if (bomba.timer < 60) {
        if (Math.floor(bomba.timer / 5) % 2 === 0) return;
    }
    
    drawRect(x, y - halfS + p * 2, s * 0.9, s * 0.4, '#00AA00');
    drawRect(x, y - halfS - p * 2, s * 0.6, s * 0.3, '#FF0000');
    drawRect(x, y - halfS - p * 4, s * 0.3, s * 0.3, '#FF0000');
    drawRect(x, y - halfS - p, s * 0.7, p * 2, '#FFFFFF');
    drawRect(x, y - s * 0.1, s * 0.4, s * 0.2, '#FFDBAC');
    drawRect(x - s * 0.1, y - s * 0.2, p, p, 'black');
    drawRect(x + s * 0.1, y - s * 0.2, p, p, 'black');
    drawRect(x, y, s * 0.3, p, '#FF0000');
    drawRect(x, y + s * 0.2, s * 1.0, s * 0.4, '#00AA00');
    drawRect(x, y + s * 0.4, s * 0.8, s * 0.2, '#8B4513');
    
    const armFrame = Math.floor(bomba.frame);
    let armOffset = 0;
    if (armFrame === 0 || armFrame === 2) {
        armOffset = s * 0.15;
    } else {
        armOffset = -s * 0.15;
    }
    
    drawRect(x - s * 0.4 + armOffset, y + s * 0.1, s * 0.2, s * 0.3, '#00AA00');
    drawRect(x + s * 0.4 - armOffset, y + s * 0.1, s * 0.2, s * 0.3, '#00AA00');
    
    const bombSize = s * 0.3;
    const bombColor = bomba.timer < 100 ? '#FF0000' : '#FF9900';
    
    drawCircle(x - s * 0.4 + armOffset, y + s * 0.25, bombSize, bombColor);
    drawRect(x - s * 0.4 + armOffset, y + s * 0.25 - bombSize/3, bombSize/2, bombSize/4, '#666666');
    drawCircle(x + s * 0.4 - armOffset, y + s * 0.25, bombSize, bombColor);
    drawRect(x + s * 0.4 - armOffset, y + s * 0.25 - bombSize/3, bombSize/2, bombSize/4, '#666666');
    
    if (Math.floor(gameFrame / 10) % 2 === 0) {
        drawRect(x - s * 0.4 + armOffset, y + s * 0.25 - bombSize, bombSize/3, bombSize/2, '#FFFF00');
        drawRect(x + s * 0.4 - armOffset, y + s * 0.25 - bombSize, bombSize/3, bombSize/2, '#FFFF00');
    }
    
    drawRect(x - s * 0.15, y + s * 0.6, s * 0.2, s * 0.3, '#8B4513');
    drawRect(x + s * 0.15, y + s * 0.6, s * 0.2, s * 0.3, '#8B4513');
    
    if (bomba.timer < 120) {
        const timeAlpha = bomba.timer / 120;
        ctx.fillStyle = `rgba(255, 0, 0, ${0.5 + 0.5 * Math.sin(gameFrame * 0.2)})`;
        ctx.beginPath();
        ctx.arc(x, y - s * 1.5, s * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText(Math.ceil(bomba.timer / 60), x, y - s * 1.5 + 3);
    }
}

function drawTitleCharacters() {
    ctx.clearRect(0, 0, W, H);
    
    const MIN_DIM = Math.min(W, H);
    const TREE_SIZE = MIN_DIM * 0.12;
    const CHARACTER_SIZE = MIN_DIM * 0.08;
    const OFFSET = W * 0.25;
    const CENTER_X = W / 2;
    const CENTER_Y = H / 2;
    
    tree.x = CENTER_X;
    tree.y = CENTER_Y;
    tree.size = TREE_SIZE;
    drawTree();
    tree.size = 40;
    
    const santaX = CENTER_X + OFFSET;
    const santaY = CENTER_Y + CHARACTER_SIZE * 0.2;
    drawSanta(santaX, santaY, CHARACTER_SIZE, gameFrame / 5);
    
    const enemyX = CENTER_X - OFFSET;
    const enemyY = CENTER_Y + CHARACTER_SIZE * 0.2;
    const e = {
        x: enemyX,
        y: enemyY,
        size: CHARACTER_SIZE,
        color: ENEMY_TYPES[0].color,
        walkFrame: gameFrame / 15
    };
    
    const s = e.size;
    const color = e.color;
    const halfS = s / 2;
    drawShadow(e.x, e.y + halfS + 4, s * 1.2, s * 0.8);
    
    const walkFrame = Math.floor(e.walkFrame % 3);
    let legOffsetL = 0;
    let legOffsetR = 0;
    let bodyTilt = 0;
    
    if (walkFrame === 0) {
        legOffsetL = s * 0.15;
        legOffsetR = -s * 0.15;
        bodyTilt = -s * 0.05;
    } else if (walkFrame === 1) {
        legOffsetL = 0;
        legOffsetR = 0;
        bodyTilt = 0;
    } else if (walkFrame === 2) {
        legOffsetL = -s * 0.15;
        legOffsetR = s * 0.15;
        bodyTilt = s * 0.05;
    }
    
    let suitColor = color;
    if (color === '#666666') suitColor = '#444444';
    
    const headY = e.y - halfS + bodyTilt;
    const hairColor = '#333333';
    const skinColor = '#39ff14';
    const beardColor = '#39ff14';
    
    drawRect(e.x, headY + s * 0.0, s * 0.8, s * 0.2, hairColor);
    drawRect(e.x, headY + s * 0.25, s * 0.6, s * 0.2, skinColor);
    drawRect(e.x, headY + s * 0.25, s * 0.7, s * 0.2, 'black');
    drawRect(e.x, headY + s * 0.5, s * 0.8, s * 0.25, beardColor);
    
    const bodyY = e.y + s * 0.45 + bodyTilt * 0.5;
    drawRect(e.x, bodyY, s * 0.8, s * 0.4, suitColor);
    drawRect(e.x, e.y + s * 0.25, s * 0.2, s * 0.1, 'white');
    drawRect(e.x, e.y + s * 0.35, s * 0.1, s * 0.2, color);
    
    const legY = e.y + s * 0.7;
    drawRect(e.x - s * 0.15 + legOffsetL, legY, s * 0.2, s * 0.3, '#333333');
    drawRect(e.x + s * 0.15 + legOffsetR, legY, s * 0.2, s * 0.3, '#333333');
}

function drawGameObjects() {
    ctx.clearRect(0, 0, W, H);
    
    if (tree.damageGlitchTimer > 0) {
        const shakeX = Math.random() * 4 - 2;
        const shakeY = Math.random() * 4 - 2;
        ctx.setTransform(1, 0, 0, 1, shakeX, shakeY);
        const hue = Math.floor(Math.random() * 360);
        ctx.filter = `hue-rotate(${hue}deg) brightness(1.5)`;
    } else {
        ctx.filter = 'none';
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    
    ctx.globalAlpha = 1;
    drawTree();
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.filter = 'none';
    
    drawEnemies();
    drawBullets();
    drawSanta(santa.x, santa.y, santa.size, santa.frame);
    drawBomba();
    explosions.forEach(exp => exp.draw());
    floatingTexts.forEach(t => t.draw());
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.filter = 'none';
    ctx.globalAlpha = 1;
    
    if (dialogue.duration > 0) {
        drawDialogueBubble(santa.x, santa.y, dialogue.message);
    }
    
    drawHUD();
}

function drawTree() {
    const treeBaseW = tree.size * 2;
    const baseCenterY = tree.y + tree.size / 2;
    drawShadow(tree.x, baseCenterY + 15, treeBaseW * 1.4, treeBaseW * 0.8);
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
    
    const SECTION_HEIGHT_FACTOR = 0.7;
    const SECTION_GAP_FACTOR = 0.4;
    const baseH = treeBaseW * SECTION_HEIGHT_FACTOR;
    const h1 = baseH * 1.0;
    const h2 = baseH * 0.8;
    const h3 = baseH * 0.6;
    const totalTreeHeight = h1 + h2 * SECTION_GAP_FACTOR + h3 * SECTION_GAP_FACTOR + tree.size * 0.25;
    const treeTopY = tree.y - totalTreeHeight / 2;
    const Y_TOP_BASE = treeTopY;
    
    const SECTIONS_CONFIG = [
        { factor: 0.6, height: h3, yCenter: Y_TOP_BASE + h3 / 2 },
        { factor: 0.8, height: h2, yCenter: Y_TOP_BASE + h3 + h2 / 2 - (h2 * SECTION_GAP_FACTOR) },
        { factor: 1.0, height: h1, yCenter: Y_TOP_BASE + h3 + h2 - (h2 * SECTION_GAP_FACTOR * 2) + h1 * 0.1 }
    ];
    
    const ORNAMENTS = [
        { x: -10, y: SECTIONS_CONFIG[2].yCenter + 15, color: 'yellow' }, 
        { x: 15, y: SECTIONS_CONFIG[2].yCenter + 30, color: 'red' },
        { x: -8, y: SECTIONS_CONFIG[1].yCenter + 0, color: 'blue' }, 
        { x: 10, y: SECTIONS_CONFIG[1].yCenter - 10, color: 'magenta' },
        { x: -5, y: SECTIONS_CONFIG[0].yCenter - 5, color: 'cyan' }, 
        { x: 5, y: SECTIONS_CONFIG[0].yCenter - 15, color: 'yellow' }
    ];
    
    const trunkY = SECTIONS_CONFIG[2].yCenter + h1 / 2 + tree.size * 0.1;
    drawRect(tree.x, trunkY, tree.size * 0.2, tree.size * 0.3, '#8B4513');
    
    SECTIONS_CONFIG.forEach((sec) => {
        const w = treeBaseW * sec.factor;
        const h = sec.height;
        const topY = sec.yCenter - h / 2;
        const bottomY = sec.yCenter + h / 2;
        
        ctx.fillStyle = tree.color;
        ctx.beginPath();
        ctx.moveTo(tree.x, topY);
        ctx.lineTo(tree.x - w * 0.5, bottomY);
        ctx.lineTo(tree.x + w * 0.5, bottomY);
        ctx.closePath();
        ctx.fill();
    });
    
    const pulse = Math.floor(gameFrame / 10) % 3;
    const lightColors = ['yellow', 'red', 'blue'];
    
    ORNAMENTS.forEach((ornament, index) => {
        drawCircle(tree.x + ornament.x, ornament.y, tree.size * 0.075, ornament.color);
    });
    
    drawCircle(tree.x - tree.size * 0.3, SECTIONS_CONFIG[2].yCenter + 0, tree.size * 0.1, lightColors[(pulse + 0) % 3]);
    drawCircle(tree.x + tree.size * 0.25, SECTIONS_CONFIG[1].yCenter - 20, tree.size * 0.1, lightColors[(pulse + 1) % 3]);
    drawCircle(tree.x + 0, SECTIONS_CONFIG[2].yCenter + tree.size * 0.5, tree.size * 0.1, lightColors[(pulse + 2) % 3]);
    drawRect(tree.x, SECTIONS_CONFIG[0].yCenter - h3 * 0.5 - tree.size * 0.2, tree.size * 0.25, tree.size * 0.25, 'yellow');
}

function drawEnemies() {
    enemies.forEach(e => {
        const x = e.x;
        const y = e.y;
        const pulse = 1 + Math.sin(gameFrame * 0.1 * e.speed) * 0.05;
        const s = ENEMY_BASE_SIZE * pulse;
        const color = e.color;
        const halfS = s / 2;
        
        drawShadow(x, y + halfS + 4, s * 1.2, s * 0.8);
        
        const walkFrame = Math.floor(e.walkFrame);
        let legOffsetL = 0;
        let legOffsetR = 0;
        let bodyTilt = 0;
        
        if (walkFrame === 0) {
            legOffsetL = s * 0.15;
            legOffsetR = -s * 0.15;
            bodyTilt = -s * 0.05;
        } else if (walkFrame === 1) {
            legOffsetL = 0;
            legOffsetR = 0;
            bodyTilt = 0;
        } else if (walkFrame === 2) {
            legOffsetL = -s * 0.15;
            legOffsetR = s * 0.15;
            bodyTilt = s * 0.05;
        }
        
        let suitColor = color;
        if (color === '#666666') suitColor = '#444444';
        else if (color === '#990000') suitColor = '#660000';
        else if (color === '#000066') suitColor = '#000044';
        
        const headY = y - halfS + bodyTilt;
        const hairColor = '#333333';
        const skinColor = '#39ff14';
        const beardColor = '#39ff14';
        
        drawRect(x, headY + s * 0.0, s * 0.8, s * 0.2, hairColor);
        drawRect(x, headY + s * 0.25, s * 0.6, s * 0.2, skinColor);
        drawRect(x, headY + s * 0.25, s * 0.7, s * 0.2, 'black');
        drawRect(x, headY + s * 0.5, s * 0.8, s * 0.25, beardColor);
        
        const bodyY = y + s * 0.45 + bodyTilt * 0.5;
        drawRect(x, bodyY, s * 0.8, s * 0.4, suitColor);
        drawRect(x, y + s * 0.25, s * 0.2, s * 0.1, 'white');
        drawRect(x, y + s * 0.35, s * 0.1, s * 0.2, color);
        
        const legY = y + s * 0.7;
        drawRect(x - s * 0.15 + legOffsetL, legY, s * 0.2, s * 0.3, '#333333');
        drawRect(x + s * 0.15 + legOffsetR, legY, s * 0.2, s * 0.3, '#333333');
    });
}

function drawBullets() {
    bullets.forEach(b => {
        ctx.shadowColor = b.color;
        ctx.shadowBlur = 5;
        drawRect(b.x, b.y, b.size, b.size, b.color);
        ctx.shadowBlur = 0;
    });
}

function drawDialogueBubble(x, y, message) {
    const FONT_SIZE = 12;
    const MAX_WIDTH = 280;
    const MAX_LINES = 4;
    const PADDING = 10;
    const LINE_HEIGHT = FONT_SIZE + 6;
    
    ctx.font = `${FONT_SIZE}px 'Press Start 2P', monospace`;
    ctx.textAlign = 'center';
    
    function splitTextIntoLines(text, maxWidth) {
        const words = text.split(' ');
        const lines = [];
        let currentLine = '';
        
        for (let i = 0; i < words.length; i++) {
            const word = words[i];
            const testLine = currentLine ? `${currentLine} ${word}` : word;
            const testWidth = ctx.measureText(testLine).width;
            
            if (testWidth <= maxWidth) {
                currentLine = testLine;
            } else {
                if (currentLine) {
                    lines.push(currentLine);
                }
                
                if (ctx.measureText(word).width > maxWidth) {
                    let remainingWord = word;
                    while (remainingWord.length > 0) {
                        let segment = '';
                        for (let j = 0; j < remainingWord.length; j++) {
                            const testSegment = segment + remainingWord[j];
                            if (ctx.measureText(testSegment).width <= maxWidth) {
                                segment = testSegment;
                            } else {
                                break;
                            }
                        }
                        lines.push(segment);
                        remainingWord = remainingWord.slice(segment.length);
                    }
                    currentLine = '';
                } else {
                    currentLine = word;
                }
            }
        }
        
        if (currentLine) {
            lines.push(currentLine);
        }
        
        return lines;
    }
    
    let lines = splitTextIntoLines(message, MAX_WIDTH);
    
    if (lines.length > MAX_LINES) {
        lines = lines.slice(0, MAX_LINES);
        lines[MAX_LINES - 1] = lines[MAX_LINES - 1].slice(0, -3) + '...';
    }
    
    let maxLineWidth = 0;
    for (const line of lines) {
        const lineWidth = ctx.measureText(line).width;
        maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    
    const bubbleW = Math.min(maxLineWidth + PADDING * 2, MAX_WIDTH + PADDING * 2);
    const bubbleH = (lines.length * LINE_HEIGHT) + PADDING * 2;
    const bubbleX = x - bubbleW / 2;
    const bubbleY = y - santa.size - bubbleH - 15;
    
    ctx.fillStyle = 'white';
    ctx.fillRect(bubbleX, bubbleY, bubbleW, bubbleH);
    
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 3;
    ctx.strokeRect(bubbleX, bubbleY, bubbleW, bubbleH);
    
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(x - 8, bubbleY + bubbleH);
    ctx.lineTo(x + 8, bubbleY + bubbleH);
    ctx.lineTo(x, bubbleY + bubbleH + 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(x - 8, bubbleY + bubbleH);
    ctx.lineTo(x + 8, bubbleY + bubbleH);
    ctx.lineTo(x, bubbleY + bubbleH + 10);
    ctx.closePath();
    ctx.stroke();
    
    ctx.fillStyle = 'black';
    ctx.textAlign = 'center';
    
    lines.forEach((line, index) => {
        const textY = bubbleY + PADDING + (index * LINE_HEIGHT) + FONT_SIZE;
        ctx.fillText(line, x, textY);
    });
}

function drawHUD() {
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 5;
    ctx.lineWidth = 3;
    ctx.font = '20px "Press Start 2P", monospace';
    
    // Puntuaci√≥n
    ctx.fillStyle = '#FFD700';
    ctx.textAlign = 'left';
    ctx.fillText(`PUNTOS: ${score}`, 10, 30);
    
    // Indicador de BOMBA
    const nextBomba = BOMBA_SCORE_HIT - (score - lastBombaScore);
    if (nextBomba > 0) {
        ctx.fillStyle = '#FF9900';
        ctx.textAlign = 'left';
        ctx.fillText(`BOMBA: ${nextBomba}`, 10, 60);
    } else if (bomba.active) {
        ctx.fillStyle = '#FF0000';
        ctx.textAlign = 'left';
        const timeLeft = Math.ceil(bomba.timer / 60);
        ctx.fillText(`¬°BOMBA! ${timeLeft}s`, 10, 60);
    }
    
    // Barra de Vida del √ÅRBOL
    const treeHealthRatio = tree.health / tree.maxHealth;
    const barWidth = 300;
    const barHeight = 20;
    const barX = W / 2 - barWidth / 2;
    const barY = 15;
    
    if (tree.healingGlowTimer > 0) {
        const glowAlpha = tree.healingGlowTimer / GLOW_DURATION * 0.7;
        ctx.fillStyle = `rgba(0, 255, 0, ${glowAlpha})`;
        ctx.fillRect(barX - 8, barY - 8, barWidth + 16, barHeight + 16);
    }
    
    ctx.fillStyle = '#333333';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    ctx.fillStyle = treeHealthRatio > 0.5 ? '#00FF00' : (treeHealthRatio > 0.2 ? '#FFD700' : '#FF0000');
    ctx.fillRect(barX, barY, barWidth * treeHealthRatio, barHeight);
    
    ctx.strokeStyle = '#000000';
    ctx.strokeRect(barX, barY, barWidth, barHeight);
    ctx.strokeStyle = '#FFFFFF';
    ctx.strokeRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);
    
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText(`√ÅRBOL`, W / 2, barY + barHeight + 25);
    
    // Barra de Vida de SANTA
    const santaHealthRatio = santa.health / santa.maxHealth;
    const santaBarWidth = 150;
    const santaBarHeight = 15;
    const santaBarX = W - santaBarWidth - 10;
    const santaBarY = 15;
    
    ctx.fillStyle = '#333333';
    ctx.fillRect(santaBarX, santaBarY, santaBarWidth, santaBarHeight);
    
    ctx.fillStyle = santaHealthRatio > 0.5 ? '#00FFFF' : (santaHealthRatio > 0.2 ? '#FFD700' : '#FF0000');
    ctx.fillRect(santaBarX, santaBarY, santaBarWidth * santaHealthRatio, santaBarHeight);
    
    ctx.strokeStyle = '#000000';
    ctx.strokeRect(santaBarX, santaBarY, santaBarWidth, santaBarHeight);
    ctx.strokeStyle = '#FFFFFF';
    ctx.strokeRect(santaBarX - 1, santaBarY - 1, santaBarWidth + 2, santaBarHeight + 2);
    
    ctx.fillStyle = 'white';
    ctx.textAlign = 'right';
    ctx.fillText(`SANTA`, W - 10, santaBarY + santaBarHeight + 5);
    
    // Barra de POWER UP
    const powerBarWidth = 300;
    const powerBarHeight = 15;
    const powerBarX = W / 2 - powerBarWidth / 2;
    const powerBarY = H - 35;
    
    let powerColor = '#FF00FF';
    let barFillWidth;
    let barText;
    
    if (santa.invincibleTimer > 0) {
        const durationRatio = santa.invincibleTimer / POWERUP_DURATION;
        barFillWidth = powerBarWidth * durationRatio;
        powerColor = (Math.floor(gameFrame / 5) % 2 === 0) ? '#00FFFF' : '#FF00FF';
        barText = `INVENCIBLE: ${Math.ceil(santa.invincibleTimer / 60)}s`;
    } else {
        const accumulationRatio = Math.min(1, enemiesDefeatedSincePowerUp / ENEMIES_FOR_POWERUP);
        barFillWidth = powerBarWidth * accumulationRatio;
        powerColor = '#FF00FF';
        barText = `POWER UP: ${enemiesDefeatedSincePowerUp}/${ENEMIES_FOR_POWERUP} ENEMIGOS`;
    }
    
    ctx.fillStyle = '#333333';
    ctx.fillRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);
    
    ctx.fillStyle = powerColor;
    if (santa.invincibleTimer > 0) {
        ctx.shadowColor = powerColor;
        ctx.shadowBlur = 10;
    }
    
    ctx.fillRect(powerBarX, powerBarY, barFillWidth, powerBarHeight);
    ctx.shadowBlur = 5;
    
    ctx.strokeStyle = '#000000';
    ctx.strokeRect(powerBarX, powerBarY, powerBarWidth, powerBarHeight);
    ctx.strokeStyle = '#FFFFFF';
    ctx.strokeRect(powerBarX - 1, powerBarY - 1, powerBarWidth + 2, powerBarHeight + 2);
    
    ctx.shadowBlur = 5;
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText(barText, W / 2, powerBarY - 10);
    
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
}

// --- 7. BUCLE PRINCIPAL Y RESET ---
let lastTime = 0;

function gameLoop(timestamp) {
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    
    if (gameState === 'TITLE') {
        drawTitleCharacters();
    } else if (gameState === 'PLAYING') {
        updateGame(deltaTime);
        drawGameObjects();
    } else if (gameState === 'GAME_OVER') {
        // No hacer nada, el modal ya est√° mostrado
    }
    
    requestAnimationFrame(gameLoop);
}

function resetGame() {
    if (backgroundMusicSource) {
        try { backgroundMusicSource.stop(); } catch (e) {}
        backgroundMusicSource = null;
    }
    
    santa.x = BASE_W / 2 - tree.size * 2;
    santa.y = BASE_H / 2 + tree.size * 2;
    santa.frame = 0;
    santa.health = santa.maxHealth;
    santa.invincible = false;
    santa.invincibleTimer = 0;
    santa.hitTimer = 0;
    
    tree.health = tree.maxHealth;
    tree.healingGlowTimer = 0;
    tree.damageGlitchTimer = 0;
    
    score = 0;
    lastHealScore = 0;
    enemies = [];
    bullets = [];
    explosions = [];
    floatingTexts = [];
    enemiesDefeatedSincePowerUp = 0;
    powerUpTimer = 0;
    gameFrame = 0;
    
    dialogue.message = "¬°Feliz Navidad! O como lo llama el 1%, 'Temporada de Consumo Forzado'.";
    dialogue.duration = PHRASE_DURATION;
    dialogue.powerUpMessage = null;
    timeSinceLastPhrase = 0;
    
    bomba.active = false;
    lastBombaScore = 0;
    
    // Ocultar modal de Game Over
    gameOverModal.style.display = "none";
}

// OCULTAR CONTROLES AL INICIO
if (isMobile) {
    controls.style.display = 'none';
    shootButton.style.display = 'none';
}
audioToggle.style.display = 'none';

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
