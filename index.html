<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EL SANTA DEFENDER</title>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: monospace;
            position: relative;
        }

        /* Estilo del Canvas Base (relaciÃ³n 800x600) */
        #gameCanvas {
            border: 4px solid #cc0000;
            background-color: #006600; 
            touch-action: none; 
            cursor: pointer; 
            /* Reglas Responsive */
            display: block;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
        }

        /* --- Control de Audio --- */
        #audioToggle {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #cc0000;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            display: none;
            pointer-events: auto;
        }

        /* --- Controles TÃ¡ctiles (Joystick) --- */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: none;
            pointer-events: auto;
        }

        .joystick-container {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            position: absolute;
            touch-action: none;
        }

        .action-button {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #cc0000;
            border: 5px solid #fff;
            color: #fff;
            font-size: 1.5em;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: auto;
            display: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <button id="audioToggle">ðŸ”Š</button>

    <div class="controls" id="mobileControls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
    </div>
    <div class="action-button" id="shootButton">FUEGO</div>

    <script>
        // --- 1. CONFIGURACIÃ“N INICIAL Y DETECCIÃ“N ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_W = 800;
        const BASE_H = 600;
        let W = BASE_W; 
        let H = BASE_H;
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Estados del Juego
        let gameState = 'TITLE';

        // Referencias a los controles y el nuevo botÃ³n de audio
        const controls = document.getElementById('mobileControls');
        const shootButton = document.getElementById('shootButton');
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const audioToggle = document.getElementById('audioToggle');

        // Constantes del juego
        const PLAYER_SPEED = 4;
        const BULLET_SPEED = 8;
        const JOYSTICK_RADIUS = 75; 
        const PHRASE_DURATION = 300; 
        const PHRASE_INTERVAL = 8000; 
        
        // --- POWER-UP CONSTANTES ---
        const ENEMIES_FOR_POWERUP = 10;
        const POWERUP_DURATION = 300; 
        
        // --- TIPOS DE ENEMIGOS (Velocidad Variable) ---
        const ENEMY_TYPES = [
            { speed: 1.5, color: '#666666', spawnWeight: 60 },
            { speed: 2.5, color: '#990000', spawnWeight: 30 },
            { speed: 1.0, color: '#000066', spawnWeight: 10 }
        ];
        let spawnRate = 0.02;

        // --- HITO DE PUNTUACIÃ“N ---
        const HEAL_SCORE_HIT = 1000;
        let lastHealScore = 0;

        // --- 2. OBJETOS DEL JUEGO Y ESTADO ---
        let santa = {
            x: BASE_W / 2,
            y: BASE_H / 2,
            size: 20, 
            color: 'red',
            health: 10,
            maxHealth: 10, 
            dirX: 0,
            dirY: 0,
            shooting: false,
            lastShotTime: 0,
            fireRate: 200,
            frame: 0,
            invincible: false, 
            invincibleTimer: 0 
        };

        const tree = {
            x: BASE_W / 2,
            y: BASE_H / 2,
            size: 40,
            color: '#00aa00', 
            health: 50,
            maxHealth: 50
        };
        const treeHealthMax = tree.maxHealth;

        let bullets = [];
        let enemies = [];
        let explosions = []; 
        let score = 0;
        let enemiesDefeatedSincePowerUp = 0; 
        let powerUpTimer = 0; 
        
        let dialogue = {
            // **FRASE INICIAL ANTI-CAPITALISTA**
            message: "Â¡Feliz Navidad! O como lo llama el 1%, 'Temporada de Consumo Forzado'.",
            duration: PHRASE_DURATION 
        };

        // **FRASE DE INVENCIBILIDAD ANTI-CAPITALISTA**
        const invincibilityPhrase = "Â¡Fuera de aquÃ­, parÃ¡sitos capitalistas!";
        
        // **FRASES SARCÃSTICAS Y CRÃTICAS AL CAPITALISMO**
        const sarcasticPhrases = [
            // Ãrbol con ALTA salud (40+ HP): Sarcasmo sobre la estabilidad y la codicia
            { min: 40, phrases: [
                "Â¡Luchando por el Ã¡rbol, el Ãºnico bien pÃºblico que queda en pie!", 
                "Â¡Mis elfos no tienen sindicato, son la verdadera tragedia aquÃ­, no estos demonios!", 
                "Â¡La avaricia ha creado monstruos... literalmente! Â¡Que ironÃ­a!", 
                "Â¡El precio de la hora extra es lo que realmente duele, no sus mordiscos!", 
                "Â¡Defender este Ã¡rbol es la nueva 'responsabilidad social corporativa'!"
            ] },
            // Ãrbol con SALUD MEDIA (25+ HP): CrÃ­tica al sistema y el esfuerzo
            { min: 25, phrases: [
                "Â¿En serio? Â¿Tantos enemigos y la riqueza sigue concentrada en los de arriba?", 
                "Â¡Esto es lo que pasa cuando privatizas el Polo Norte!", 
                "Â¡No hay suficientes incentivos fiscales para seguir con esta masacre!", 
                "Â¡Al menos estos monstruos trabajan, a diferencia de los parÃ¡sitos de la junta directiva!", 
                "Â¡Mi nÃ³mina estÃ¡ congelada, pero mi furia no!"
            ] },
            // Ãrbol con BAJA salud (1+ HP): Humor negro y desesperaciÃ³n
            { min: 1, phrases: [
                "Â¡La recesiÃ³n de salud llegÃ³ antes de lo esperado! Â¡SÃ¡lvese quien pueda!", 
                "Â¡Parece que el mercado se estÃ¡ 'ajustando' a la baja, justo como mi moral!", 
                "Â¡Si perdemos, que el Ã¡rbol se declare en bancarrota para salvar mis activos!", 
                "Â¡La prÃ³xima Navidad, los juguetes serÃ¡n hechos por la IA... y serÃ¡n aÃºn mÃ¡s caros!", 
                "Â¡El verdadero regalo es un sistema que funcione, no mÃ¡s juguetes!"
            ] }
        ];

        let timeSinceLastPhrase = 0;

        // --- WEB AUDIO API (Control y GeneraciÃ³n de Sonido) ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        let isMuted = false;
        let backgroundMusicSource = null; 

        // Frecuencias MIDI para "Jingle Bells" (en G Mayor)
        const C4 = 261.63, D4 = 293.66, E4 = 329.63, F4 = 349.23, G4 = 392.00, A4 = 440.00; 
        const C5 = 523.25, D5 = 587.33, E5 = 659.25, G5 = 783.99;
        
        // NOTAS: 1.0 = Negra; 0.5 = Corchea; 2.0 = Blanca
        const tempo = 0.25; 

        // MelodÃ­a precisa de "Jingle Bells" (Verso y Estribillo, 16 compases en 2/4)
        const melody = [
            // Verso (Compases 1-8: Dashing through the snow...)
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 }, 
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: C4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: E4, duration: 2.0 }, 
            { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 },
            { freq: F4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.25 }, { freq: D4, duration: 0.25 },
            { freq: D4, duration: 0.5 }, { freq: D4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: G4, duration: 2.0 }, 

            // Estribillo (Compases 9-16: Jingle Bells, jingle bells...)
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 1.0 },
            { freq: E4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: C4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: E4, duration: 2.0 }, 
            { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: F4, duration: 0.5 },
            { freq: F4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.5 }, { freq: E4, duration: 0.25 }, { freq: D4, duration: 0.25 },
            { freq: G4, duration: 0.5 }, { freq: G4, duration: 0.5 }, { freq: F4, duration: 0.5 }, { freq: D4, duration: 0.5 },
            { freq: C4, duration: 2.0 } 
        ];


        function startBackgroundMusic() {
            if (backgroundMusicSource) {
                if (backgroundMusicSource.playbackState === backgroundMusicSource.PLAYING_STATE) {
                    try { backgroundMusicSource.stop(audioContext.currentTime); } catch (e) {}
                }
                backgroundMusicSource = null;
            }

            const playSequence = (time) => {
                if (gameState !== 'PLAYING' || isMuted) {
                    backgroundMusicSource = null;
                    return;
                }
                
                let currentTime = time;
                
                backgroundMusicSource = audioContext.createOscillator();
                backgroundMusicSource.type = 'square'; 

                const musicGain = audioContext.createGain();
                musicGain.gain.setValueAtTime(0.4, audioContext.currentTime); 
                
                backgroundMusicSource.connect(musicGain);
                musicGain.connect(masterGain); 

                melody.forEach(note => {
                    const duration = note.duration * tempo; 
                    
                    if (note.freq > 0) {
                         backgroundMusicSource.frequency.setValueAtTime(note.freq, currentTime);
                         musicGain.gain.setValueAtTime(0.4, currentTime);
                         musicGain.gain.exponentialRampToValueAtTime(0.0001, currentTime + duration * 0.95);
                    } else {
                         musicGain.gain.setValueAtTime(0.0001, currentTime);
                    }
                    
                    currentTime += duration;
                });
                
                backgroundMusicSource.start(time);
                backgroundMusicSource.stop(currentTime); 
                
                backgroundMusicSource.onended = () => {
                    if (gameState === 'PLAYING' && !isMuted) {
                        playSequence(audioContext.currentTime);
                    } else {
                         backgroundMusicSource = null; 
                    }
                };
            };
            
            playSequence(audioContext.currentTime);
        }

        /**
         * Genera un efecto de sonido simple de 8 bits.
         */
        function playSound(frequency, duration, type, endFrequency = frequency, volume = 0.5) {
            if (isMuted) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            if (endFrequency !== frequency) {
                oscillator.frequency.linearRampToValueAtTime(endFrequency, audioContext.currentTime + duration);
            }

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(masterGain);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playExplosion(pitch) {
            playSound(pitch, 0.1, 'triangle', pitch * 0.5, 0.6);
        }

        function playHealSound() {
            playSound(400, 0.15, 'sine', 800, 0.8); 
        }

        function toggleAudio() {
            isMuted = !isMuted;
            if (isMuted) {
                // Silenciar el MasterGain para detener MÃšSICA y EFECTOS
                masterGain.gain.setValueAtTime(0, audioContext.currentTime);
                audioToggle.textContent = 'ðŸ”‡';
                
                // Detener la reproducciÃ³n del loop actual explÃ­citamente si estÃ¡ activo
                if (backgroundMusicSource) {
                     try { backgroundMusicSource.stop(audioContext.currentTime); } catch (e) {}
                     backgroundMusicSource = null;
                }
                
            } else {
                // Reactivar el MasterGain y reintentar la mÃºsica
                masterGain.gain.setValueAtTime(1, audioContext.currentTime);
                audioToggle.textContent = 'ðŸ”Š';
                
                // Si la mÃºsica estaba detenida debido al mute, la reiniciamos
                if (gameState === 'PLAYING' && !backgroundMusicSource) {
                     startBackgroundMusic();
                }
            }
        }
        
        audioToggle.addEventListener('click', toggleAudio);
        
        // --- Listener para el atajo de teclado TAB ---
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Tab' && gameState === 'PLAYING') {
                e.preventDefault();
                toggleAudio();
            }
        });
        
        // --- CLASE EXPLOSIÃ“N (Sin cambios) ---
        class Explosion {
            constructor(x, y, color) {
                this.particles = [];
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        size: Math.random() * 4 + 2, 
                        color: color,
                        vx: Math.random() * 6 - 3, 
                        vy: Math.random() * 6 - 3, 
                        life: 30 
                    });
                }
            }
            update() {
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                });
                this.particles = this.particles.filter(p => p.life > 0);
                return this.particles.length > 0;
            }
            draw() {
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                });
            }
        }
        
        // --- 3. RESPONSIVE DESIGN Y MANEJO DE VENTANA ---

        function resizeGame() {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const aspectR = BASE_W / BASE_H;
            
            let newW, newH;

            if (viewportW / viewportH > aspectR) {
                newH = viewportH;
                newW = viewportH * aspectR;
            } else {
                newW = viewportW;
                newH = viewportW / aspectR;
            }
            
            canvas.style.width = newW + 'px';
            canvas.style.height = newH + 'px';

            W = BASE_W;
            H = BASE_H;
            canvas.width = W;
            canvas.height = H;
        }

        window.addEventListener('resize', resizeGame);
        resizeGame();


        // --- 4. MANEJO DE EVENTOS (TÃ­tulo y Controles) ---
        
        function handleStartGame() {
            if (gameState === 'TITLE') {
                audioContext.resume();
                
                playSound(440, 0.01, 'sine', 440, 0); 
                
                gameState = 'PLAYING';
                resetGame();
                
                startBackgroundMusic(); // INICIA LA MÃšSICA

                if (isMobile) {
                    controls.style.display = 'block';
                    shootButton.style.display = 'flex';
                }
                audioToggle.style.display = 'block';
            }
        }

        canvas.addEventListener('mousedown', handleStartGame);
        canvas.addEventListener('touchstart', (e) => {
            if (gameState === 'TITLE') {
                e.preventDefault();
                handleStartGame();
            }
        });
        
        // --- Controles de juego (Joystick y Teclado) ---
        let keys = {};
        if (!isMobile) {
            window.addEventListener('keydown', (e) => {
                if (gameState === 'PLAYING') {
                    keys[e.code] = true;
                }
            });
            window.addEventListener('keyup', (e) => {
                if (gameState === 'PLAYING') {
                    keys[e.code] = false;
                    if (e.code === 'Space') santa.shooting = false; 
                }
            });
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = true;
            });
            window.addEventListener('mouseup', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = false;
            });
        }
        
        let joystickActive = false;
        let startX, startY;

        if (isMobile) {
            joystickContainer.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            });
            joystickContainer.addEventListener('touchmove', (e) => {
                if (!joystickActive || gameState !== 'PLAYING') return;
                const touch = e.touches[0];
                let deltaX = touch.clientX - startX;
                let deltaY = touch.clientY - startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > JOYSTICK_RADIUS) {
                    deltaX = (deltaX / distance) * JOYSTICK_RADIUS;
                    deltaY = (deltaY / distance) * JOYSTICK_RADIUS;
                }
                joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                santa.dirX = deltaX / JOYSTICK_RADIUS;
                santa.dirY = deltaY / JOYSTICK_RADIUS;
            });
            const resetJoystick = () => {
                joystickActive = false;
                santa.dirX = 0;
                santa.dirY = 0;
                joystickHandle.style.transform = `translate(0px, 0px)`;
            };
            joystickContainer.addEventListener('touchend', resetJoystick);
            joystickContainer.addEventListener('touchcancel', resetJoystick);

            shootButton.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = true;
            });
            shootButton.addEventListener('touchend', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = false;
            });
        }


        // --- 5. LÃ“GICA DEL JUEGO (UPDATE) ---

        function handleShooting(deltaTime) {
            const currentFireRate = (santa.invincibleTimer > 0) ? 50 : santa.fireRate;
            
            if ((!isMobile && (keys['Space'] || santa.shooting)) || (isMobile && santa.shooting) || (santa.invincibleTimer > 0)) {
                const currentTime = Date.now();
                if (currentTime - santa.lastShotTime > currentFireRate) {
                    const dx = tree.x - santa.x;
                    const dy = tree.y - santa.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const nx = dx / dist;
                    const ny = dy / dist;

                    bullets.push({
                        x: santa.x,
                        y: santa.y,
                        size: (santa.invincibleTimer > 0) ? 12 : 8,
                        color: (santa.invincibleTimer > 0) ? '#00FFFF' : 'yellow',
                        dirX: nx,
                        dirY: ny
                    });
                    santa.lastShotTime = currentTime;
                    playSound(700, 0.05, 'square');
                }
            }
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.dirX * BULLET_SPEED;
                bullet.y += bullet.dirY * BULLET_SPEED;

                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        explosions.push(new Explosion(enemy.x, enemy.y, enemy.color)); 
                        
                        enemies.splice(j, 1); 
                        bullets.splice(i, 1); 
                        score += 10;
                        enemiesDefeatedSincePowerUp++;
                        playExplosion(300);
                        
                        hit = true;
                        break;
                    }
                }

                if (!hit && (bullet.x < 0 || bullet.x > W || bullet.y < 0 || bullet.y > H)) {
                    bullets.splice(i, 1);
                }
            }
        }
        
        function updatePowerUp(deltaTime) {
            // Invencibilidad y Power-Up
            if (santa.invincibleTimer > 0) {
                santa.invincibleTimer -= (deltaTime / (1000 / 60)); 
                if (santa.invincibleTimer <= 0) {
                    santa.invincible = false;
                    santa.invincibleTimer = 0;
                    dialogue.message = "Â¡Se agotÃ³ la invencibilidad!";
                    dialogue.duration = PHRASE_DURATION;
                }
            }
            
            if (enemiesDefeatedSincePowerUp >= ENEMIES_FOR_POWERUP) {
                // El power-up rellena la salud de Santa
                santa.health = santa.maxHealth; 
                
                // Activa la invencibilidad
                santa.invincible = true;
                santa.invincibleTimer = POWERUP_DURATION; 
                
                enemiesDefeatedSincePowerUp = 0; 
                dialogue.message = invincibilityPhrase; // Usa la nueva frase anti-capitalista
                dialogue.duration = PHRASE_DURATION;
                playSound(300, 0.2, 'sawtooth', 700);
            }
        }

        function checkHealHit() {
            if (score >= lastHealScore + HEAL_SCORE_HIT) {
                lastHealScore += HEAL_SCORE_HIT;

                const healAmount = tree.maxHealth * 0.5;
                const newHealth = Math.min(tree.maxHealth, tree.health + healAmount);
                
                if (newHealth > tree.health) {
                    tree.health = newHealth;
                    dialogue.message = `Â¡HITO! El Ã¡rbol se ha regenerado un 50%. HP: ${tree.health}`;
                    dialogue.duration = PHRASE_DURATION;
                    
                    playHealSound();
                }
            }
        }

        function updatePlayerMovement() {
            if (!isMobile) {
                santa.dirX = 0;
                santa.dirY = 0;
                if (keys['KeyA'] || keys['ArrowLeft']) santa.dirX = -1;
                if (keys['KeyD'] || keys['ArrowRight']) santa.dirX = 1;
                if (keys['KeyW'] || keys['ArrowUp']) santa.dirY = -1;
                if (keys['KeyS'] || keys['ArrowDown']) santa.dirY = 1;
            }
            const magnitude = Math.sqrt(santa.dirX * santa.dirX + santa.dirY * santa.dirY);
            if (magnitude > 0) {
                const nx = santa.dirX / magnitude;
                const ny = santa.dirY / magnitude;
                santa.x += nx * PLAYER_SPEED;
                santa.y += ny * PLAYER_SPEED;
                santa.frame = (santa.frame + 0.1) % 2; 
                santa.x = Math.max(santa.size / 2, Math.min(W - santa.size / 2, santa.x));
                santa.y = Math.max(santa.size / 2, Math.min(H - santa.size / 2, santa.y));
            } else {
                 santa.frame = 0; 
            }
        }
        function updateExplosions() {
             for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function spawnEnemies() {
            if (Math.random() < spawnRate) { 
                
                let totalWeight = ENEMY_TYPES.reduce((sum, type) => sum + type.spawnWeight, 0);
                let randomValue = Math.random() * totalWeight;
                let selectedType = ENEMY_TYPES[0];

                for (const type of ENEMY_TYPES) {
                    randomValue -= type.spawnWeight;
                    if (randomValue <= 0) {
                        selectedType = type;
                        break;
                    }
                }

                const size = 15;
                const edge = Math.floor(Math.random() * 4); 
                let x, y;
                switch (edge) {
                    case 0: x = Math.random() * W; y = -size; break;
                    case 1: x = W + size; y = Math.random() * H; break;
                    case 2: x = Math.random() * W; y = H + size; break;
                    case 3: x = -size; y = Math.random() * H; break;
                }
                
                enemies.push({ 
                    x: x, 
                    y: y, 
                    size: size, 
                    color: selectedType.color,
                    speed: selectedType.speed
                });
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = tree.x - enemy.x;
                const dy = tree.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / dist;
                const ny = dy / dist;
                
                enemy.x += nx * enemy.speed; 
                enemy.y += ny * enemy.speed;
                
                let destroyed = false;

                // LÃ“GICA DE DAÃ‘O A SANTA CON INVENCIBILIDAD
                if (checkCollision(enemy, santa)) {
                    if (!santa.invincible) {
                        santa.health -= 1;
                        explosions.push(new Explosion(enemy.x, enemy.y, 'white'));
                        playSound(150, 0.1, 'square', 100);
                        
                        if (santa.health <= 0) {
                            alert('GAME OVER! Santa ha sido sobrepasado. PuntuaciÃ³n: ' + score);
                            playSound(200, 1.0, 'sine', 50);
                            gameState = 'TITLE';
                            resetGame();
                            if (isMobile) {
                                controls.style.display = 'none';
                                shootButton.style.display = 'none';
                            }
                            audioToggle.style.display = 'none';
                            return; 
                        }
                    } else {
                        explosions.push(new Explosion(enemy.x, enemy.y, '#FF00FF'));
                    }

                    enemies.splice(i, 1);
                    destroyed = true;
                }
                
                // LÃ³gica de daÃ±o al Ãrbol (Solo si no ha sido destruido al daÃ±ar a Santa)
                if (!destroyed && checkCollision(enemy, tree)) {
                    tree.health -= 1;
                    enemies.splice(i, 1);
                    
                    if (tree.health <= 0) {
                        alert('GAME OVER! El Ã¡rbol ha sido talado. PuntuaciÃ³n: ' + score);
                        playSound(200, 1.0, 'sine', 50);
                        gameState = 'TITLE'; 
                        resetGame(); 
                        if (isMobile) {
                            controls.style.display = 'none';
                            shootButton.style.display = 'none';
                        }
                        audioToggle.style.display = 'none';
                        return;
                    }
                }
            }
        }
        
        function updateDialogue(deltaTime) {
            if (dialogue.duration > 0) {
                dialogue.duration -= (deltaTime / (1000 / 60)); 
            }
            timeSinceLastPhrase += deltaTime;
            if (timeSinceLastPhrase > PHRASE_INTERVAL && dialogue.duration <= 0) {
                let eligiblePhrases = [];
                for(const group of sarcasticPhrases) {
                    if (tree.health >= group.min) {
                        eligiblePhrases = group.phrases;
                        break;
                    }
                }
                if (eligiblePhrases.length > 0) {
                    const newPhrase = eligiblePhrases[Math.floor(Math.random() * eligiblePhrases.length)];
                    dialogue.message = newPhrase;
                    dialogue.duration = PHRASE_DURATION; 
                    timeSinceLastPhrase = 0;
                }
            }
        }
        function checkCollision(objA, objB) {
            return objA.x < objB.x + objB.size && objA.x + objA.size > objB.x &&
                   objA.y < objB.y + objB.size && objA.y + objB.size > objB.y;
        }


        function updateGame(deltaTime) {
            updatePlayerMovement();
            updatePowerUp(deltaTime); 
            handleShooting(deltaTime);
            updateBullets();
            updateExplosions(); 
            spawnEnemies();
            updateEnemies();
            updateDialogue(deltaTime); 
            checkHealHit();
        }

        // --- 6. RENDERIZADO (DRAW) ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x - w / 2, y - h / 2, w, h);
        }
        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSanta(x, y, size, frame) {
            if (santa.invincible && Math.floor(santa.invincibleTimer / 5) % 2 === 0) {
                return;
            }

            const legOffset = (Math.floor(frame) === 0) ? 3 : -3;
            drawRect(x, y, size, size, 'red');
            drawRect(x, y + 4, size, size / 2, 'white'); 
            drawRect(x, y - 8, size / 2, size / 2, 'white'); 
            drawRect(x, y - 10, size, size / 3, 'red'); 
            drawRect(x - 5, y - 2, 3, 3, 'black');
            drawRect(x + 5, y - 2, 3, 3, 'black');
            drawRect(x - 5 + legOffset, y + 8, 4, 4, 'black');
            drawRect(x + 5 - legOffset, y + 8, 4, 4, 'black');
        }

        function drawTitleText(x, y, message, fontSize, color, align = 'center') {
            ctx.fillStyle = color;
            ctx.font = `${fontSize}px monospace`;
            ctx.textAlign = align;
            ctx.fillText(message, x, y);
        }

        function drawTitleScreen() {
            ctx.fillStyle = '#003300';
            ctx.fillRect(0, 0, W, H);

            drawTitleText(W / 2, H / 2 - 150, "EL SANTA DEFENDER", 60, '#cc0000');
            drawTitleText(W / 2, H / 2 - 80, "La Lucha Contra la Codicia", 24, 'white');
            drawSanta(W / 4, H / 2 + 50, 40, 0); 
            drawTitleText(W / 4, H / 2 + 100, "Santa", 20, 'white');
            
            const instructions = isMobile ? 
                ["**MOVIL**:", "Joystick Izq: Mover", "BotÃ³n FUEGO: Disparar", "Toca la pantalla para JUGAR"] :
                ["**PC**:", "WASD / Flechas: Mover", "Espacio / Click: Disparar", "TAB: Silenciar Audio", "Click en la pantalla para JUGAR"];
            
            let lineY = H / 2 - 50;
            const lineX = W * 0.6;

            instructions.forEach(line => {
                const color = line.startsWith('**') ? '#ffcc00' : 'white';
                const text = line.replace(/\*\*/g, '');
                drawTitleText(lineX, lineY, text, 20, color, 'left'); 
                lineY += 30;
            });

            drawTitleText(W / 2, H - 50, "Â¡La Navidad depende de ti!", 24, '#00aa00');
        }

        function applyPsychedelicGlitch() {
            ctx.translate(Math.random() * 4 - 2, Math.random() * 4 - 2); 
            if (Math.random() < 0.5) {
                ctx.globalAlpha = 0.8;
                ctx.filter = `hue-rotate(${Math.random() * 360}deg) saturate(200%)`;
            } else {
                 ctx.filter = 'none';
                 ctx.globalAlpha = 1;
            }
        }
        
        function drawGameObjects() {
            if (santa.invincibleTimer > 0) {
                applyPsychedelicGlitch();
            } else {
                ctx.filter = 'none';
                ctx.globalAlpha = 1;
            }
            
            const titleText = "EL SANTA DEFENDER";
            const fontSize = 48; 
            const titleColor = '#004d00'; 
            ctx.fillStyle = titleColor;
            ctx.font = `${fontSize}px monospace`;
            ctx.textAlign = 'center';
            const titleY = H / 2 + fontSize * 1.5;
            ctx.fillText(titleText, W / 2 + 2, titleY + 2);
            ctx.fillText(titleText, W / 2 - 2, titleY - 2);
            ctx.fillText(titleText, W / 2, titleY);

            drawTree();
            drawEnemies();
            drawBullets();
            drawSanta(santa.x, santa.y, santa.size, santa.frame); 
            explosions.forEach(exp => exp.draw());
            drawHUD();
            
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.filter = 'none';
            ctx.globalAlpha = 1;

            if (santa.invincibleTimer > 0) {
                ctx.fillStyle = '#FF00FF';
                const barWidth = 300 * (santa.invincibleTimer / POWERUP_DURATION);
                ctx.fillRect(W / 2 - 150, H - 25, barWidth, 15);
                drawTitleText(W/2, H-10, "INVENCIBLE", 16, '#FF00FF');
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                const barWidth = 300 * (enemiesDefeatedSincePowerUp / ENEMIES_FOR_POWERUP);
                ctx.fillRect(W / 2 - 150, H - 25, barWidth, 15);
                drawTitleText(W/2, H-10, `Racha: ${enemiesDefeatedSincePowerUp}/${ENEMIES_FOR_POWERUP}`, 16, 'white');
            }
        }
        
        function drawTree() {
            drawRect(tree.x, tree.y + tree.size / 2 - 5, 10, 10, '#8B4513');
            ctx.fillStyle = tree.color;
            ctx.beginPath();
            ctx.moveTo(tree.x, tree.y - tree.size); 
            ctx.lineTo(tree.x - tree.size, tree.y + tree.size / 2);
            ctx.lineTo(tree.x + tree.size, tree.y + tree.size / 2);
            ctx.closePath();
            ctx.fill();
            drawCircle(tree.x - 10, tree.y - 15, 3, 'yellow');
            drawCircle(tree.x + 15, tree.y, 3, 'red');
            drawCircle(tree.x - 5, tree.y + 10, 3, 'blue');
            ctx.fillStyle = 'white';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`HP: ${tree.health}/${tree.maxHealth}`, tree.x, tree.y + tree.size + 10);
        }

        function drawEnemies() {
            enemies.forEach(e => {
                drawRect(e.x, e.y, e.size, e.size, e.color);
                drawRect(e.x + e.size / 4, e.y + e.size / 4, e.size / 3, e.size / 3, 'black'); 
            });
        }
        function drawBullets() {
            bullets.forEach(b => {
                drawRect(b.x, b.y, b.size, b.size, b.color);
            });
        }
        
        function drawDialogueBubble(x, y, message) {
            const FONT_SIZE = 16;
            const MAX_WIDTH_CHARS = 25; // Caracteres mÃ¡ximos por lÃ­nea
            const PADDING = 8;
            const LINE_HEIGHT = FONT_SIZE + 4;
            
            ctx.font = `${FONT_SIZE}px monospace`;
            ctx.textAlign = 'center';

            // 1. Envolver el texto
            let lines = [message];
            let maxLineW = 0;
            
            // SimulaciÃ³n de auto-envoltura simple
            if (message.length > MAX_WIDTH_CHARS) {
                const words = message.split(' ');
                lines = [''];
                let currentLine = 0;
                
                for (const word of words) {
                    // Si aÃ±adir la palabra actual supera el lÃ­mite, crea una nueva lÃ­nea
                    if (lines[currentLine].length + word.length + 1 > MAX_WIDTH_CHARS && currentLine < 1) {
                        currentLine++;
                        lines.push(word + ' ');
                    } else {
                        lines[currentLine] += word + ' ';
                    }
                }
            }

            // 2. Medir el ancho mÃ¡ximo de lÃ­nea
            for (const line of lines) {
                maxLineW = Math.max(maxLineW, ctx.measureText(line.trim()).width);
            }

            const textWidth = maxLineW;
            const numLines = lines.length;
            const bubbleW = textWidth + PADDING * 2;
            const bubbleH = (numLines * LINE_HEIGHT) + PADDING * 1.5;
            
            const bubbleX = x - bubbleW / 2;
            const bubbleY = y - santa.size - bubbleH - 10; // 10px de separaciÃ³n

            // 3. Dibujar el Globo (RectÃ¡ngulo redondeado)
            ctx.fillStyle = 'white';
            ctx.fillRect(bubbleX, bubbleY, bubbleW, bubbleH);
            
            // 4. Dibujar el Pico (TriÃ¡ngulo que apunta a Santa)
            ctx.beginPath();
            ctx.moveTo(x - 5, bubbleY + bubbleH);
            ctx.lineTo(x + 5, bubbleY + bubbleH);
            ctx.lineTo(x, bubbleY + bubbleH + 6); // 6px de altura del pico
            ctx.closePath();
            ctx.fill();

            // 5. Dibujar el Texto
            ctx.fillStyle = 'black';
            let currentTextY = bubbleY + PADDING + LINE_HEIGHT * 0.75;
            
            lines.forEach((line, index) => {
                ctx.fillText(line.trim(), x, currentTextY + index * LINE_HEIGHT);
            });
        }


        function drawHUD() {
            ctx.fillStyle = 'white';
            ctx.font = '20px monospace';
            
            // PuntuaciÃ³n
            ctx.textAlign = 'left';
            ctx.fillText(`PuntuaciÃ³n: ${score}`, 10, 30);
            
            // Salud Santa (Esquina superior derecha) - AHORA CON BARRA
            const healthRatio = santa.health / santa.maxHealth;
            const barWidth = 150;
            const barHeight = 15;
            const barX = W - barWidth - 10;
            const barY = 15;

            ctx.strokeStyle = 'white';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            ctx.fillStyle = healthRatio > 0.5 ? '#00FF00' : (healthRatio > 0.2 ? '#FFD700' : '#FF0000');
            ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);

            ctx.fillStyle = 'white';
            ctx.textAlign = 'right';
            ctx.fillText(`Santa: ${santa.health}/${santa.maxHealth}`, W - 10, 30);
            
            // DiÃ¡logo (si estÃ¡ activo, encima de Santa)
            if (dialogue.duration > 0) {
                drawDialogueBubble(santa.x, santa.y, dialogue.message);
            }
        }


        // --- 7. BUCLE PRINCIPAL Y RESET ---

        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, W, H);
            
            if (gameState === 'TITLE') {
                drawTitleScreen();
            } else if (gameState === 'PLAYING') {
                updateGame(deltaTime); 
                drawGameObjects();
            }

            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            // Detener la mÃºsica si existe
            if (backgroundMusicSource) {
                try { backgroundMusicSource.stop(); } catch (e) {}
                backgroundMusicSource = null;
            }
            
            santa.x = BASE_W / 2;
            santa.y = BASE_H / 2;
            santa.frame = 0;
            santa.health = santa.maxHealth;
            santa.invincible = false;
            santa.invincibleTimer = 0;
            tree.health = tree.maxHealth;
            score = 0;
            lastHealScore = 0;
            enemies = [];
            bullets = [];
            explosions = []; 
            enemiesDefeatedSincePowerUp = 0; 
            powerUpTimer = 0; 
            // Usa la nueva frase inicial
            dialogue.message = "Â¡Feliz Navidad! O como lo llama el 1%, 'Temporada de Consumo Forzado'."; 
            dialogue.duration = PHRASE_DURATION;
            timeSinceLastPhrase = 0;
        }

        audioToggle.style.display = 'none';

        // Iniciar el bucle de juego
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
