<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EL SANTA DEFENDER</title>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: monospace;
            position: relative;
        }

        /* Estilo del Canvas Base (relaciÃ³n 800x600) */
        #gameCanvas {
            border: 4px solid #cc0000;
            background-color: #006600; 
            touch-action: none; 
            cursor: pointer; 
            /* Reglas Responsive */
            display: block;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
        }

        /* --- Control de Audio --- */
        #audioToggle {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #cc0000;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 20px;
            cursor: pointer;
            user-select: none;
            display: none;
            pointer-events: auto;
        }

        /* --- Controles TÃ¡ctiles (Joystick) --- */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: none;
            pointer-events: auto;
        }

        .joystick-container {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.7);
            position: absolute;
            touch-action: none;
        }

        .action-button {
            position: absolute;
            bottom: 50px;
            right: 50px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #cc0000;
            border: 5px solid #fff;
            color: #fff;
            font-size: 1.5em;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: auto;
            display: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <button id="audioToggle">ðŸ”Š</button>

    <div class="controls" id="mobileControls">
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>
    </div>
    <div class="action-button" id="shootButton">FUEGO</div>

    <script>
        // --- 1. CONFIGURACIÃ“N INICIAL Y DETECCIÃ“N ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BASE_W = 800;
        const BASE_H = 600;
        let W = BASE_W; 
        let H = BASE_H;
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Estados del Juego
        let gameState = 'TITLE';

        // Referencias a los controles y el nuevo botÃ³n de audio
        const controls = document.getElementById('mobileControls');
        const shootButton = document.getElementById('shootButton');
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const audioToggle = document.getElementById('audioToggle');

        // Constantes del juego
        const PLAYER_SPEED = 4;
        const BULLET_SPEED = 8;
        const JOYSTICK_RADIUS = 75; 
        const PHRASE_DURATION = 300; 
        const PHRASE_INTERVAL = 8000; 
        
        // --- POWER-UP CONSTANTES ---
        const ENEMIES_FOR_POWERUP = 10;
        const POWERUP_DURATION = 300; 
        
        // --- TIPOS DE ENEMIGOS (Velocidad Variable) ---
        const ENEMY_TYPES = [
            { speed: 1.5, color: '#666666', spawnWeight: 60 },
            { speed: 2.5, color: '#990000', spawnWeight: 30 },
            { speed: 1.0, color: '#000066', spawnWeight: 10 }
        ];
        let spawnRate = 0.02;

        // --- HITO DE PUNTUACIÃ“N ---
        const HEAL_SCORE_HIT = 1000;
        let lastHealScore = 0;

        // --- 2. OBJETOS DEL JUEGO Y ESTADO ---
        let santa = {
            x: BASE_W / 2,
            y: BASE_H / 2,
            size: 20, 
            color: 'red',
            health: 10,
            maxHealth: 10, 
            dirX: 0,
            dirY: 0,
            shooting: false,
            lastShotTime: 0,
            fireRate: 200,
            frame: 0,
            invincible: false, 
            invincibleTimer: 0 
        };

        const tree = {
            x: BASE_W / 2,
            y: BASE_H / 2,
            size: 40,
            color: '#00aa00', 
            health: 50,
            maxHealth: 50
        };
        const treeHealthMax = tree.maxHealth;

        let bullets = [];
        let enemies = [];
        let explosions = []; 
        let score = 0;
        let enemiesDefeatedSincePowerUp = 0; 
        let powerUpTimer = 0; 
        
        let dialogue = {
            message: "Â¡Feliz Navidad, mis pequeÃ±os capitalistas!",
            duration: PHRASE_DURATION 
        };

        const invincibilityPhrase = "Â¡Soy invencible, como el espÃ­ritu capitalista... por un momento!";
        const sarcasticPhrases = [
            { min: 40, phrases: ["Â¡No me cansarÃ© hasta que mis nietos hereden el negocio!", "Â¡Este traje es de marca, no lo ensucies!", "Â¡El valor de mercado de este pino es astronÃ³mico!", "Â¡Estos muchachos son peores que el trÃ¡fico en Black Friday!", "Â¡La codicia no los hace inmortales, chicos!"] },
            { min: 25, phrases: ["Â¿De verdad? Â¿Solo un arbolito? Â¡QuÃ© falta de ambiciÃ³n!", "Â¡Un poco de dolor harÃ¡ que aprecien mÃ¡s la Navidad.", "Â¡PagarÃ­a por un cafÃ© con estos niveles de adrenalina!", "Â¡Mis elfos son mÃ¡s eficientes que esta fuerza de trabajo!", "Â¡DeberÃ­an estar invirtiendo en protecciÃ³n, no en deforestaciÃ³n!"] },
            { min: 1, phrases: ["Â¡Parece que vamos a necesitar un plan B... o un nuevo Ã¡rbol!", "Â¡Mi seguro de vida cubre esto, Â¿verdad?!", "Â¡Alguien va a pasar la Navidad en la lista negra!", "Â¡Si sobrevivo, subirÃ© el precio de los juguetes en un 200%!", "Â¡Al menos es mejor que la reuniÃ³n de la junta directiva de enero!"] }
        ];

        let timeSinceLastPhrase = 0;

        // --- WEB AUDIO API (Control y GeneraciÃ³n de Sonido) ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioContext.createGain();
        masterGain.connect(audioContext.destination);
        let isMuted = false;

        /**
         * Genera un efecto de sonido simple de 8 bits.
         */
        function playSound(frequency, duration, type, endFrequency = frequency, volume = 0.5) {
            if (isMuted) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            if (endFrequency !== frequency) {
                oscillator.frequency.linearRampToValueAtTime(endFrequency, audioContext.currentTime + duration);
            }

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(masterGain);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playExplosion(pitch) {
            playSound(pitch, 0.1, 'triangle', pitch * 0.5, 0.6);
        }

        function playHealSound() {
            playSound(400, 0.15, 'sine', 800, 0.8); 
        }

        function toggleAudio() {
            isMuted = !isMuted;
            if (isMuted) {
                masterGain.gain.setValueAtTime(0, audioContext.currentTime);
                audioToggle.textContent = 'ðŸ”‡';
            } else {
                masterGain.gain.setValueAtTime(1, audioContext.currentTime);
                audioToggle.textContent = 'ðŸ”Š';
            }
        }
        
        audioToggle.addEventListener('click', toggleAudio);
        
        // --- Listener para el atajo de teclado TAB (NUEVO) ---
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Tab' && gameState === 'PLAYING') {
                e.preventDefault(); // Evita que el foco salte
                toggleAudio();
            }
        });
        
        // --- CLASE EXPLOSIÃ“N (Sin cambios) ---
        class Explosion {
            constructor(x, y, color) {
                this.particles = [];
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        size: Math.random() * 4 + 2, 
                        color: color,
                        vx: Math.random() * 6 - 3, 
                        vy: Math.random() * 6 - 3, 
                        life: 30 
                    });
                }
            }
            update() {
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                });
                this.particles = this.particles.filter(p => p.life > 0);
                return this.particles.length > 0;
            }
            draw() {
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
                });
            }
        }
        
        // --- 3. RESPONSIVE DESIGN Y MANEJO DE VENTANA ---

        function resizeGame() {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;
            const aspectR = BASE_W / BASE_H;
            
            let newW, newH;

            if (viewportW / viewportH > aspectR) {
                newH = viewportH;
                newW = viewportH * aspectR;
            } else {
                newW = viewportW;
                newH = viewportW / aspectR;
            }
            
            canvas.style.width = newW + 'px';
            canvas.style.height = newH + 'px';

            W = BASE_W;
            H = BASE_H;
            canvas.width = W;
            canvas.height = H;
        }

        window.addEventListener('resize', resizeGame);
        resizeGame();


        // --- 4. MANEJO DE EVENTOS (TÃ­tulo y Controles) ---
        
        function handleStartGame() {
            if (gameState === 'TITLE') {
                playSound(440, 0.01, 'sine', 440, 0); 

                gameState = 'PLAYING';
                resetGame();
                if (isMobile) {
                    controls.style.display = 'block';
                    shootButton.style.display = 'flex';
                }
                audioToggle.style.display = 'block';
            }
        }

        canvas.addEventListener('mousedown', handleStartGame);
        canvas.addEventListener('touchstart', (e) => {
            if (gameState === 'TITLE') {
                e.preventDefault();
                handleStartGame();
            }
        });
        
        // --- Controles de juego (Joystick y Teclado) ---
        let keys = {};
        if (!isMobile) {
            window.addEventListener('keydown', (e) => {
                // Control de movimiento
                if (gameState === 'PLAYING') {
                    keys[e.code] = true;
                }
            });
            window.addEventListener('keyup', (e) => {
                if (gameState === 'PLAYING') {
                    keys[e.code] = false;
                    // Asegurar que el disparo se detenga si se suelta espacio
                    if (e.code === 'Space') santa.shooting = false; 
                }
            });
            window.addEventListener('mousedown', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = true;
            });
            window.addEventListener('mouseup', (e) => {
                if (e.button === 0 && gameState === 'PLAYING') santa.shooting = false;
            });
        }
        
        let joystickActive = false;
        let startX, startY;

        if (isMobile) {
            joystickContainer.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            });
            joystickContainer.addEventListener('touchmove', (e) => {
                if (!joystickActive || gameState !== 'PLAYING') return;
                const touch = e.touches[0];
                let deltaX = touch.clientX - startX;
                let deltaY = touch.clientY - startY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > JOYSTICK_RADIUS) {
                    deltaX = (deltaX / distance) * JOYSTICK_RADIUS;
                    deltaY = (deltaY / distance) * JOYSTICK_RADIUS;
                }
                joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                santa.dirX = deltaX / JOYSTICK_RADIUS;
                santa.dirY = deltaY / JOYSTICK_RADIUS;
            });
            const resetJoystick = () => {
                joystickActive = false;
                santa.dirX = 0;
                santa.dirY = 0;
                joystickHandle.style.transform = `translate(0px, 0px)`;
            };
            joystickContainer.addEventListener('touchend', resetJoystick);
            joystickContainer.addEventListener('touchcancel', resetJoystick);

            shootButton.addEventListener('touchstart', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = true;
            });
            shootButton.addEventListener('touchend', (e) => {
                if (gameState !== 'PLAYING') return;
                e.preventDefault();
                santa.shooting = false;
            });
        }


        // --- 5. LÃ“GICA DEL JUEGO (UPDATE) ---

        function handleShooting(deltaTime) {
            const currentFireRate = (santa.invincibleTimer > 0) ? 50 : santa.fireRate;
            
            if ((!isMobile && (keys['Space'] || santa.shooting)) || (isMobile && santa.shooting) || (santa.invincibleTimer > 0)) {
                const currentTime = Date.now();
                if (currentTime - santa.lastShotTime > currentFireRate) {
                    const dx = tree.x - santa.x;
                    const dy = tree.y - santa.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const nx = dx / dist;
                    const ny = dy / dist;

                    bullets.push({
                        x: santa.x,
                        y: santa.y,
                        size: (santa.invincibleTimer > 0) ? 12 : 8,
                        color: (santa.invincibleTimer > 0) ? '#00FFFF' : 'yellow',
                        dirX: nx,
                        dirY: ny
                    });
                    santa.lastShotTime = currentTime;
                    playSound(700, 0.05, 'square');
                }
            }
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.dirX * BULLET_SPEED;
                bullet.y += bullet.dirY * BULLET_SPEED;

                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (checkCollision(bullet, enemy)) {
                        explosions.push(new Explosion(enemy.x, enemy.y, enemy.color)); 
                        
                        enemies.splice(j, 1); 
                        bullets.splice(i, 1); 
                        score += 10;
                        enemiesDefeatedSincePowerUp++;
                        playExplosion(300);
                        
                        hit = true;
                        break;
                    }
                }

                if (!hit && (bullet.x < 0 || bullet.x > W || bullet.y < 0 || bullet.y > H)) {
                    bullets.splice(i, 1);
                }
            }
        }
        
        function updatePowerUp(deltaTime) {
            // Invencibilidad y Power-Up
            if (santa.invincibleTimer > 0) {
                santa.invincibleTimer -= (deltaTime / (1000 / 60)); 
                if (santa.invincibleTimer <= 0) {
                    santa.invincible = false;
                    santa.invincibleTimer = 0;
                    dialogue.message = "Â¡Se agotÃ³ la invencibilidad!";
                    dialogue.duration = PHRASE_DURATION;
                }
            }
            
            if (enemiesDefeatedSincePowerUp >= ENEMIES_FOR_POWERUP) {
                // El power-up rellena la salud de Santa
                santa.health = santa.maxHealth; 
                
                // Activa la invencibilidad
                santa.invincible = true;
                santa.invincibleTimer = POWERUP_DURATION; 
                
                enemiesDefeatedSincePowerUp = 0; 
                dialogue.message = invincibilityPhrase;
                dialogue.duration = PHRASE_DURATION;
                playSound(300, 0.2, 'sawtooth', 700);
            }
        }

        function checkHealHit() {
            if (score >= lastHealScore + HEAL_SCORE_HIT) {
                lastHealScore += HEAL_SCORE_HIT;

                const healAmount = tree.maxHealth * 0.5;
                const newHealth = Math.min(tree.maxHealth, tree.health + healAmount);
                
                if (newHealth > tree.health) {
                    tree.health = newHealth;
                    dialogue.message = `Â¡HITO! El Ã¡rbol se ha regenerado un 50%. HP: ${tree.health}`;
                    dialogue.duration = PHRASE_DURATION;
                    
                    playHealSound();
                }
            }
        }

        function updatePlayerMovement() {
            if (!isMobile) {
                santa.dirX = 0;
                santa.dirY = 0;
                if (keys['KeyA'] || keys['ArrowLeft']) santa.dirX = -1;
                if (keys['KeyD'] || keys['ArrowRight']) santa.dirX = 1;
                if (keys['KeyW'] || keys['ArrowUp']) santa.dirY = -1;
                if (keys['KeyS'] || keys['ArrowDown']) santa.dirY = 1;
            }
            const magnitude = Math.sqrt(santa.dirX * santa.dirX + santa.dirY * santa.dirY);
            if (magnitude > 0) {
                const nx = santa.dirX / magnitude;
                const ny = santa.dirY / magnitude;
                santa.x += nx * PLAYER_SPEED;
                santa.y += ny * PLAYER_SPEED;
                santa.frame = (santa.frame + 0.1) % 2; 
                santa.x = Math.max(santa.size / 2, Math.min(W - santa.size / 2, santa.x));
                santa.y = Math.max(santa.size / 2, Math.min(H - santa.size / 2, santa.y));
            } else {
                 santa.frame = 0; 
            }
        }
        function updateExplosions() {
             for (let i = explosions.length - 1; i >= 0; i--) {
                if (!explosions[i].update()) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function spawnEnemies() {
            if (Math.random() < spawnRate) { 
                
                let totalWeight = ENEMY_TYPES.reduce((sum, type) => sum + type.spawnWeight, 0);
                let randomValue = Math.random() * totalWeight;
                let selectedType = ENEMY_TYPES[0];

                for (const type of ENEMY_TYPES) {
                    randomValue -= type.spawnWeight;
                    if (randomValue <= 0) {
                        selectedType = type;
                        break;
                    }
                }

                const size = 15;
                const edge = Math.floor(Math.random() * 4); 
                let x, y;
                switch (edge) {
                    case 0: x = Math.random() * W; y = -size; break;
                    case 1: x = W + size; y = Math.random() * H; break;
                    case 2: x = Math.random() * W; y = H + size; break;
                    case 3: x = -size; y = Math.random() * H; break;
                }
                
                enemies.push({ 
                    x: x, 
                    y: y, 
                    size: size, 
                    color: selectedType.color,
                    speed: selectedType.speed
                });
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = tree.x - enemy.x;
                const dy = tree.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / dist;
                const ny = dy / dist;
                
                enemy.x += nx * enemy.speed; 
                enemy.y += ny * enemy.speed;
                
                let destroyed = false;

                // LÃ“GICA DE DAÃ‘O A SANTA CON INVENCIBILIDAD
                if (checkCollision(enemy, santa)) {
                    if (!santa.invincible) {
                        santa.health -= 1;
                        explosions.push(new Explosion(enemy.x, enemy.y, 'white'));
                        playSound(150, 0.1, 'square', 100);
                        
                        if (santa.health <= 0) {
                            alert('GAME OVER! Santa ha sido sobrepasado. PuntuaciÃ³n: ' + score);
                            playSound(200, 1.0, 'sine', 50);
                            gameState = 'TITLE';
                            resetGame();
                            if (isMobile) {
                                controls.style.display = 'none';
                                shootButton.style.display = 'none';
                            }
                            audioToggle.style.display = 'none';
                            return; 
                        }
                    } else {
                        explosions.push(new Explosion(enemy.x, enemy.y, '#FF00FF'));
                    }

                    enemies.splice(i, 1);
                    destroyed = true;
                }
                
                // LÃ³gica de daÃ±o al Ãrbol (Solo si no ha sido destruido al daÃ±ar a Santa)
                if (!destroyed && checkCollision(enemy, tree)) {
                    tree.health -= 1;
                    enemies.splice(i, 1);
                    
                    if (tree.health <= 0) {
                        alert('GAME OVER! El Ã¡rbol ha sido talado. PuntuaciÃ³n: ' + score);
                        playSound(200, 1.0, 'sine', 50);
                        gameState = 'TITLE'; 
                        resetGame(); 
                        if (isMobile) {
                            controls.style.display = 'none';
                            shootButton.style.display = 'none';
                        }
                        audioToggle.style.display = 'none';
                        return;
                    }
                }
            }
        }
        
        function updateDialogue(deltaTime) {
            if (dialogue.duration > 0) {
                dialogue.duration -= (deltaTime / (1000 / 60)); 
            }
            timeSinceLastPhrase += deltaTime;
            if (timeSinceLastPhrase > PHRASE_INTERVAL && dialogue.duration <= 0) {
                let eligiblePhrases = [];
                for(const group of sarcasticPhrases) {
                    if (tree.health >= group.min) {
                        eligiblePhrases = group.phrases;
                        break;
                    }
                }
                if (eligiblePhrases.length > 0) {
                    const newPhrase = eligiblePhrases[Math.floor(Math.random() * eligiblePhrases.length)];
                    dialogue.message = newPhrase;
                    dialogue.duration = PHRASE_DURATION; 
                    timeSinceLastPhrase = 0;
                }
            }
        }
        function checkCollision(objA, objB) {
            return objA.x < objB.x + objB.size && objA.x + objA.size > objB.x &&
                   objA.y < objB.y + objB.size && objA.y + objB.size > objB.y;
        }


        function updateGame(deltaTime) {
            updatePlayerMovement();
            updatePowerUp(deltaTime); 
            handleShooting(deltaTime);
            updateBullets();
            updateExplosions(); 
            spawnEnemies();
            updateEnemies();
            updateDialogue(deltaTime); 
            checkHealHit();
        }

        // --- 6. RENDERIZADO (DRAW) ---

        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x - w / 2, y - h / 2, w, h);
        }
        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSanta(x, y, size, frame) {
            if (santa.invincible && Math.floor(santa.invincibleTimer / 5) % 2 === 0) {
                return;
            }

            const legOffset = (Math.floor(frame) === 0) ? 3 : -3;
            drawRect(x, y, size, size, 'red');
            drawRect(x, y + 4, size, size / 2, 'white'); 
            drawRect(x, y - 8, size / 2, size / 2, 'white'); 
            drawRect(x, y - 10, size, size / 3, 'red'); 
            drawRect(x - 5, y - 2, 3, 3, 'black');
            drawRect(x + 5, y - 2, 3, 3, 'black');
            drawRect(x - 5 + legOffset, y + 8, 4, 4, 'black');
            drawRect(x + 5 - legOffset, y + 8, 4, 4, 'black');
        }

        function drawTitleText(x, y, message, fontSize, color, align = 'center') {
            ctx.fillStyle = color;
            ctx.font = `${fontSize}px monospace`;
            ctx.textAlign = align;
            ctx.fillText(message, x, y);
        }

        function drawTitleScreen() {
            ctx.fillStyle = '#003300';
            ctx.fillRect(0, 0, W, H);

            drawTitleText(W / 2, H / 2 - 150, "EL SANTA DEFENDER", 60, '#cc0000');
            drawTitleText(W / 2, H / 2 - 80, "La Lucha Contra la Codicia", 24, 'white');
            drawSanta(W / 4, H / 2 + 50, 40, 0); 
            drawTitleText(W / 4, H / 2 + 100, "Santa", 20, 'white');
            
            const instructions = isMobile ? 
                ["**MOVIL**:", "Joystick Izq: Mover", "BotÃ³n FUEGO: Disparar", "Toca la pantalla para JUGAR"] :
                ["**PC**:", "WASD / Flechas: Mover", "Espacio / Click: Disparar", "TAB: Silenciar Audio", "Click en la pantalla para JUGAR"];
            
            let lineY = H / 2 - 50;
            const lineX = W * 0.6;

            instructions.forEach(line => {
                const color = line.startsWith('**') ? '#ffcc00' : 'white';
                const text = line.replace(/\*\*/g, '');
                drawTitleText(lineX, lineY, text, 20, color, 'left'); 
                lineY += 30;
            });

            drawTitleText(W / 2, H - 50, "Â¡La Navidad depende de ti!", 24, '#00aa00');
        }

        function applyPsychedelicGlitch() {
            ctx.translate(Math.random() * 4 - 2, Math.random() * 4 - 2); 
            if (Math.random() < 0.5) {
                ctx.globalAlpha = 0.8;
                ctx.filter = `hue-rotate(${Math.random() * 360}deg) saturate(200%)`;
            } else {
                 ctx.filter = 'none';
                 ctx.globalAlpha = 1;
            }
        }
        
        function drawGameObjects() {
            if (santa.invincibleTimer > 0) {
                applyPsychedelicGlitch();
            } else {
                ctx.filter = 'none';
                ctx.globalAlpha = 1;
            }
            
            const titleText = "EL SANTA DEFENDER";
            const fontSize = 48; 
            const titleColor = '#004d00'; 
            ctx.fillStyle = titleColor;
            ctx.font = `${fontSize}px monospace`;
            ctx.textAlign = 'center';
            const titleY = H / 2 + fontSize * 1.5;
            ctx.fillText(titleText, W / 2 + 2, titleY + 2);
            ctx.fillText(titleText, W / 2 - 2, titleY - 2);
            ctx.fillText(titleText, W / 2, titleY);

            drawTree();
            drawEnemies();
            drawBullets();
            drawSanta(santa.x, santa.y, santa.size, santa.frame); 
            explosions.forEach(exp => exp.draw());
            drawHUD();
            
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.filter = 'none';
            ctx.globalAlpha = 1;

            if (santa.invincibleTimer > 0) {
                ctx.fillStyle = '#FF00FF';
                const barWidth = 300 * (santa.invincibleTimer / POWERUP_DURATION);
                ctx.fillRect(W / 2 - 150, H - 25, barWidth, 15);
                drawTitleText(W/2, H-10, "INVENCIBLE", 16, '#FF00FF');
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                const barWidth = 300 * (enemiesDefeatedSincePowerUp / ENEMIES_FOR_POWERUP);
                ctx.fillRect(W / 2 - 150, H - 25, barWidth, 15);
                drawTitleText(W/2, H-10, `Racha: ${enemiesDefeatedSincePowerUp}/${ENEMIES_FOR_POWERUP}`, 16, 'white');
            }
        }
        
        function drawTree() {
            drawRect(tree.x, tree.y + tree.size / 2 - 5, 10, 10, '#8B4513');
            ctx.fillStyle = tree.color;
            ctx.beginPath();
            ctx.moveTo(tree.x, tree.y - tree.size); 
            ctx.lineTo(tree.x - tree.size, tree.y + tree.size / 2);
            ctx.lineTo(tree.x + tree.size, tree.y + tree.size / 2);
            ctx.closePath();
            ctx.fill();
            drawCircle(tree.x - 10, tree.y - 15, 3, 'yellow');
            drawCircle(tree.x + 15, tree.y, 3, 'red');
            drawCircle(tree.x - 5, tree.y + 10, 3, 'blue');
            ctx.fillStyle = 'white';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`HP: ${tree.health}/${tree.maxHealth}`, tree.x, tree.y + tree.size + 10);
        }

        function drawEnemies() {
            enemies.forEach(e => {
                drawRect(e.x, e.y, e.size, e.size, e.color);
                drawRect(e.x + e.size / 4, e.y + e.size / 4, e.size / 3, e.size / 3, 'black'); 
            });
        }
        function drawBullets() {
            bullets.forEach(b => {
                drawRect(b.x, b.y, b.size, b.size, b.color);
            });
        }
        
        function drawDialogueBubble(x, y, message) {
            const padding = 10;
            ctx.font = '16px monospace';
            const textMetrics = ctx.measureText(message);
            const textWidth = textMetrics.width;
            const textHeight = 16;
            const bubbleW = textWidth + padding * 2;
            const bubbleH = textHeight + padding * 2;
            const bubbleX = x - bubbleW / 2;
            const bubbleY = y - santa.size - bubbleH - 5; 
            ctx.fillStyle = 'white';
            ctx.fillRect(bubbleX, bubbleY, bubbleW, bubbleH);
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.fillText(message, x, bubbleY + textHeight + padding - 2);
        }

        function drawHUD() {
            ctx.fillStyle = 'white';
            ctx.font = '20px monospace';
            
            // PuntuaciÃ³n
            ctx.textAlign = 'left';
            ctx.fillText(`PuntuaciÃ³n: ${score}`, 10, 30);
            
            // Salud Santa (Esquina superior derecha) - AHORA CON BARRA
            const healthRatio = santa.health / santa.maxHealth;
            const barWidth = 150;
            const barHeight = 15;
            const barX = W - barWidth - 10;
            const barY = 15;

            ctx.strokeStyle = 'white';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            ctx.fillStyle = healthRatio > 0.5 ? '#00FF00' : (healthRatio > 0.2 ? '#FFD700' : '#FF0000');
            ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);

            ctx.fillStyle = 'white';
            ctx.textAlign = 'right';
            ctx.fillText(`Santa: ${santa.health}/${santa.maxHealth}`, W - 10, 30);
            
            // DiÃ¡logo (si estÃ¡ activo, encima de Santa)
            if (dialogue.duration > 0) {
                drawDialogueBubble(santa.x, santa.y, dialogue.message);
            }
        }


        // --- 7. BUCLE PRINCIPAL Y RESET ---

        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            ctx.clearRect(0, 0, W, H);
            
            if (gameState === 'TITLE') {
                drawTitleScreen();
            } else if (gameState === 'PLAYING') {
                updateGame(deltaTime); 
                drawGameObjects();
            }

            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            santa.x = BASE_W / 2;
            santa.y = BASE_H / 2;
            santa.frame = 0;
            santa.health = santa.maxHealth;
            santa.invincible = false;
            santa.invincibleTimer = 0;
            tree.health = tree.maxHealth;
            score = 0;
            lastHealScore = 0;
            enemies = [];
            bullets = [];
            explosions = []; 
            enemiesDefeatedSincePowerUp = 0; 
            powerUpTimer = 0; 
            dialogue.message = "Â¡Feliz Navidad, mis pequeÃ±os capitalistas!";
            dialogue.duration = PHRASE_DURATION;
            timeSinceLastPhrase = 0;
        }

        audioToggle.style.display = 'none';

        // Iniciar el bucle de juego
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
